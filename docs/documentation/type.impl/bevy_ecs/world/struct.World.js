(function() {var type_impls = {
"foliage":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">register_system</a>&lt;M, S&gt;(&amp;mut self, system: S) -&gt; SystemId<span class=\"where fmt-newline\">where\n    S: IntoSystem&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, M&gt; + 'static,</span></h4></section></summary><div class=\"docblock\"><p>Registers a system and returns a [<code>SystemId</code>] so it can later be called by [<code>World::run_system</code>].</p>\n<p>It’s possible to register the same systems more than once, they’ll be stored separately.</p>\n<p>This is different from adding systems to a <a href=\"crate::schedule::Schedule\"><code>Schedule</code></a>,\nbecause the [<code>SystemId</code>] that is returned can be used anywhere in the [<code>World</code>] to run the associated system.\nThis allows for running systems in a pushed-based fashion.\nUsing a <a href=\"crate::schedule::Schedule\"><code>Schedule</code></a> is still preferred for most cases\ndue to its better performance and abillity to run non-conflicting systems simultaneously.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_boxed_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">register_boxed_system</a>(\n    &amp;mut self,\n    system: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/boxed/struct.Box.html\" title=\"struct alloc::boxed::Box\">Box</a>&lt;dyn System&lt;Out = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, In = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;&gt;\n) -&gt; SystemId</h4></section></summary><div class=\"docblock\"><p>Similar to [<code>Self::register_system</code>], but allows passing in a [<code>BoxedSystem</code>].</p>\n<p>This is useful if the [<code>IntoSystem</code>] implementor has already been turned into a\n<a href=\"crate::system::System\"><code>System</code></a> trait object and put in a <a href=\"https://doc.rust-lang.org/1.75.0/alloc/boxed/struct.Box.html\" title=\"struct alloc::boxed::Box\"><code>Box</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_system</a>(\n    &amp;mut self,\n    id: SystemId\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;RemovedSystem, RegisteredSystemError&gt;</h4></section></summary><div class=\"docblock\"><p>Removes a registered system and returns the system, if it exists.\nAfter removing a system, the [<code>SystemId</code>] becomes invalid and attempting to use it afterwards will result in errors.\nRe-adding the removed system will register it on a new [<code>SystemId</code>].</p>\n<p>If no system corresponds to the given [<code>SystemId</code>], this method returns an error.\nSystems are also not allowed to remove themselves, this returns an error too.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.run_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">run_system</a>(&amp;mut self, id: SystemId) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, RegisteredSystemError&gt;</h4></section></summary><div class=\"docblock\"><p>Run stored systems by their [<code>SystemId</code>].\nBefore running a system, it must first be registered.\nThe method [<code>World::register_system</code>] stores a given system and returns a [<code>SystemId</code>].\nThis is different from <a href=\"crate::system::RunSystemOnce::run_system_once\"><code>RunSystemOnce::run_system_once</code></a>,\nbecause it keeps local state between calls and change detection works correctly.</p>\n<h5 id=\"limitations\"><a href=\"#limitations\">Limitations</a></h5>\n<ul>\n<li>Stored systems cannot be chained: they can neither have an <a href=\"crate::system::In\"><code>In</code></a> nor return any values.</li>\n<li>Stored systems cannot be recursive, they cannot call themselves through <a href=\"crate::system::Commands\"><code>Commands::run_system</code></a>.</li>\n<li>Exclusive systems cannot be used.</li>\n</ul>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Resource, Default)]\n</span><span class=\"kw\">struct </span>Counter(u8);\n\n<span class=\"kw\">fn </span>increment(<span class=\"kw-2\">mut </span>counter: Local&lt;Counter&gt;) {\n   counter.<span class=\"number\">0 </span>+= <span class=\"number\">1</span>;\n   <span class=\"macro\">println!</span>(<span class=\"string\">&quot;{}&quot;</span>, counter.<span class=\"number\">0</span>);\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::default();\n<span class=\"kw\">let </span>counter_one = world.register_system(increment);\n<span class=\"kw\">let </span>counter_two = world.register_system(increment);\nworld.run_system(counter_one); <span class=\"comment\">// -&gt; 1\n</span>world.run_system(counter_one); <span class=\"comment\">// -&gt; 2\n</span>world.run_system(counter_two); <span class=\"comment\">// -&gt; 1</span></code></pre></div>\n<p>Change detection:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Resource, Default)]\n</span><span class=\"kw\">struct </span>ChangeDetector;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::default();\nworld.init_resource::&lt;ChangeDetector&gt;();\n<span class=\"kw\">let </span>detector = world.register_system(|change_detector: ResMut&lt;ChangeDetector&gt;| {\n    <span class=\"kw\">if </span>change_detector.is_changed() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">&quot;Something happened!&quot;</span>);\n    } <span class=\"kw\">else </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">&quot;Nothing happened.&quot;</span>);\n    }\n});\n\n<span class=\"comment\">// Resources are changed when they are first added\n</span><span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Something happened!\n</span><span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Nothing happened.\n</span>world.resource_mut::&lt;ChangeDetector&gt;().set_changed();\n<span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Something happened!</span></code></pre></div>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>() -&gt; World</h4></section></summary><div class=\"docblock\"><p>Creates a new empty [<code>World</code>].</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>If <a href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a> [<code>World</code>]s have been created.\nThis guarantee allows System Parameters to safely uniquely identify a [<code>World</code>],\nsince its [<code>WorldId</code>] is unique</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">id</a>(&amp;self) -&gt; WorldId</h4></section></summary><div class=\"docblock\"><p>Retrieves this [<code>World</code>]’s unique ID</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_unsafe_world_cell\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">as_unsafe_world_cell</a>(&amp;mut self) -&gt; UnsafeWorldCell&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new [<code>UnsafeWorldCell</code>] view with complete read+write access.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_unsafe_world_cell_readonly\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">as_unsafe_world_cell_readonly</a>(&amp;self) -&gt; UnsafeWorldCell&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new [<code>UnsafeWorldCell</code>] view with only read access to everything.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entities</a>(&amp;self) -&gt; &amp;Entities</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Entities</code>] collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entities_mut\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">entities_mut</a>(&amp;mut self) -&gt; &amp;mut Entities</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Entities</code>] collection mutably.</p>\n<h5 id=\"safety\"><a href=\"#safety\">Safety</a></h5>\n<p>Mutable reference must not be used to put the [<code>Entities</code>] data\nin an invalid state for this [<code>World</code>]</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.archetypes\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">archetypes</a>(&amp;self) -&gt; &amp;Archetypes</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Archetypes</code>] collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.components\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">components</a>(&amp;self) -&gt; &amp;Components</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Components</code>] collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.storages\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">storages</a>(&amp;self) -&gt; &amp;Storages</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Storages</code>] collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.bundles\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">bundles</a>(&amp;self) -&gt; &amp;Bundles</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>Bundles</code>] collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed_components\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">removed_components</a>(&amp;self) -&gt; &amp;RemovedComponentEvents</h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s [<code>RemovedComponentEvents</code>] collection</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cell\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">cell</a>(&amp;mut self) -&gt; WorldCell&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves a [<code>WorldCell</code>], which safely enables multiple mutable World accesses at the same\ntime, provided those accesses do not conflict with each other.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_component\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">init_component</a>&lt;T&gt;(&amp;mut self) -&gt; ComponentId<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new [<code>Component</code>] type and returns the [<code>ComponentId</code>] created for it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_component_with_descriptor\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">init_component_with_descriptor</a>(\n    &amp;mut self,\n    descriptor: ComponentDescriptor\n) -&gt; ComponentId</h4></section></summary><div class=\"docblock\"><p>Initializes a new [<code>Component</code>] type and returns the [<code>ComponentId</code>] created for it.</p>\n<p>This method differs from [<code>World::init_component</code>] in that it uses a [<code>ComponentDescriptor</code>]\nto initialize the new component type instead of statically available type information. This\nenables the dynamic initialization of new component definitions at runtime for advanced use cases.</p>\n<p>While the option to initialize a component from a descriptor is useful in type-erased\ncontexts, the standard <code>World::init_component</code> function should always be used instead\nwhen type information is available at compile time.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.component_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">component_id</a>&lt;T&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;ComponentId&gt;<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Returns the [<code>ComponentId</code>] of the given [<code>Component</code>] type <code>T</code>.</p>\n<p>The returned <code>ComponentId</code> is specific to the <code>World</code> instance\nit was retrieved from and should not be used with another <code>World</code> instance.</p>\n<p>Returns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>Component</code> type has not yet been initialized within\nthe <code>World</code> using [<code>World::init_component</code>].</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>ComponentA;\n\n<span class=\"kw\">let </span>component_a_id = world.init_component::&lt;ComponentA&gt;();\n\n<span class=\"macro\">assert_eq!</span>(component_a_id, world.component_id::&lt;ComponentA&gt;().unwrap())</code></pre></div>\n<h5 id=\"see-also\"><a href=\"#see-also\">See also</a></h5>\n<ul>\n<li>[<code>Components::component_id()</code>]</li>\n<li>[<code>Components::get_id()</code>]</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entity</a>(&amp;self, entity: Entity) -&gt; EntityRef&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an [<code>EntityRef</code>] that exposes read-only operations for the given <code>entity</code>.\nThis will panic if the <code>entity</code> does not exist. Use [<code>World::get_entity</code>] if you want\nto check for entity existence instead of implicitly panic-ing.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entity_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">entity_mut</a>(&amp;mut self, entity: Entity) -&gt; EntityWorldMut&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an [<code>EntityWorldMut</code>] that exposes read and write operations for the given <code>entity</code>.\nThis will panic if the <code>entity</code> does not exist. Use [<code>World::get_entity_mut</code>] if you want\nto check for entity existence instead of implicitly panic-ing.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entity_mut = world.entity_mut(entity);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = entity_mut.get_mut::&lt;Position&gt;().unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.many_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">many_entities</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [Entity; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; [EntityRef&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>Gets an [<code>EntityRef</code>] for multiple entities at once.</p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>If any entity does not exist in the world.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Getting multiple entities.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.many_entities([id1, id2]);</code></pre></div>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Trying to get a despawned entity will fail.\n</span>world.despawn(id2);\nworld.many_entities([id1, id2]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.many_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">many_entities_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [Entity; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; [EntityMut&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>Gets mutable access to multiple entities at once.</p>\n<h5 id=\"panics-2\"><a href=\"#panics-2\">Panics</a></h5>\n<p>If any entities do not exist in the world,\nor if the same entity is specified multiple times.</p>\n<h5 id=\"examples-1\"><a href=\"#examples-1\">Examples</a></h5>\n<p>Disjoint mutable access.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Disjoint mutable access.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.many_entities_mut([id1, id2]);</code></pre></div>\n<p>Trying to access the same entity multiple times will fail.</p>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code>world.many_entities_mut([id, id]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.inspect_entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">inspect_entity</a>(&amp;self, entity: Entity) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;&amp;ComponentInfo&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the components of an [<code>Entity</code>] through [<code>ComponentInfo</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_or_spawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_or_spawn</a>(&amp;mut self, entity: Entity) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;EntityWorldMut&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an [<code>EntityWorldMut</code>] for the given <code>entity</code> (if it exists) or spawns one if it doesn’t exist.\nThis will return <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> exists with a different generation.</p>\n<h5 id=\"note\"><a href=\"#note\">Note</a></h5>\n<p>Spawning a specific <code>entity</code> value is rarely the right choice. Most apps should favor [<code>World::spawn</code>].\nThis method should generally only be used for sharing entities across apps, and only when they have a\nscheme worked out to share an ID space (which doesn’t happen by default).</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_entity</a>(&amp;self, entity: Entity) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;EntityRef&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an [<code>EntityRef</code>] that exposes read-only operations for the given <code>entity</code>.\nReturns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> does not exist.\nInstead of unwrapping the value returned from this function, prefer [<code>World::entity</code>].</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>entity_ref = world.get_entity(entity).unwrap();\n<span class=\"kw\">let </span>position = entity_ref.get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_many_entities</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    entities: [Entity; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;[EntityRef&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>], Entity&gt;</h4></section></summary><div class=\"docblock\"><p>Gets an [<code>EntityRef</code>] for multiple entities at once.</p>\n<h5 id=\"errors\"><a href=\"#errors\">Errors</a></h5>\n<p>If any entity does not exist in the world.</p>\n<h5 id=\"examples-2\"><a href=\"#examples-2\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Getting multiple entities.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.get_many_entities([id1, id2]).unwrap();\n\n<span class=\"comment\">// Trying to get a despawned entity will fail.\n</span>world.despawn(id2);\n<span class=\"macro\">assert!</span>(world.get_many_entities([id1, id2]).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">iter_entities</a>(&amp;self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = EntityRef&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an [<code>Entity</code>] iterator of current entities.</p>\n<p>This is useful in contexts where you only have read-only access to the [<code>World</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">iter_entities_mut</a>(&amp;mut self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = EntityMut&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable iterator over all entities in the <code>World</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_entity_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_entity_mut</a>(&amp;mut self, entity: Entity) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;EntityWorldMut&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an [<code>EntityWorldMut</code>] that exposes read and write operations for the given <code>entity</code>.\nReturns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> does not exist.\nInstead of unwrapping the value returned from this function, prefer [<code>World::entity_mut</code>].</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entity_mut = world.get_entity_mut(entity).unwrap();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = entity_mut.get_mut::&lt;Position&gt;().unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_many_entities_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [Entity; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;[EntityMut&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>], QueryEntityError&gt;</h4></section></summary><div class=\"docblock\"><p>Gets mutable access to multiple entities.</p>\n<h5 id=\"errors-1\"><a href=\"#errors-1\">Errors</a></h5>\n<p>If any entities do not exist in the world,\nor if the same entity is specified multiple times.</p>\n<h5 id=\"examples-3\"><a href=\"#examples-3\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Disjoint mutable access.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.get_many_entities_mut([id1, id2]).unwrap();\n\n<span class=\"comment\">// Trying to access the same entity multiple times will fail.\n</span><span class=\"macro\">assert!</span>(world.get_many_entities_mut([id1, id1]).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_empty\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">spawn_empty</a>(&amp;mut self) -&gt; EntityWorldMut&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Spawns a new [<code>Entity</code>] and returns a corresponding [<code>EntityWorldMut</code>], which can be used\nto add components to the entity or retrieve its id.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Label(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Num(u32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn_empty()\n    .insert(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}) <span class=\"comment\">// add a single component\n    </span>.insert((Num(<span class=\"number\">1</span>), Label(<span class=\"string\">&quot;hello&quot;</span>))) <span class=\"comment\">// add a bundle of components\n    </span>.id();\n\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">spawn</a>&lt;B&gt;(&amp;mut self, bundle: B) -&gt; EntityWorldMut&lt;'_&gt;<span class=\"where fmt-newline\">where\n    B: Bundle,</span></h4></section></summary><div class=\"docblock\"><p>Spawns a new [<code>Entity</code>] with a given [<code>Bundle</code>] of <a href=\"%60Component%60\">components</a> and returns\na corresponding [<code>EntityWorldMut</code>], which can be used to add components to the entity or\nretrieve its id.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{bundle::Bundle, component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Velocity {\n    x: f32,\n    y: f32,\n};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Name(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n\n<span class=\"attr\">#[derive(Bundle)]\n</span><span class=\"kw\">struct </span>PhysicsBundle {\n    position: Position,\n    velocity: Velocity,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"comment\">// `spawn` can accept a single component:\n</span>world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>});\n<span class=\"comment\">// It can also accept a tuple of components:\n</span>world.spawn((\n    Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>},\n    Velocity { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">1.0 </span>},\n));\n<span class=\"comment\">// Or it can accept a pre-defined Bundle of components:\n</span>world.spawn(PhysicsBundle {\n    position: Position { x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0 </span>},\n    velocity: Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">4.0 </span>},\n});\n\n<span class=\"kw\">let </span>entity = world\n    <span class=\"comment\">// Tuples can also mix Bundles and Components\n    </span>.spawn((\n        PhysicsBundle {\n            position: Position { x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0 </span>},\n            velocity: Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">4.0 </span>},\n        },\n        Name(<span class=\"string\">&quot;Elaina Proctor&quot;</span>),\n    ))\n    <span class=\"comment\">// Calling id() will return the unique identifier for the spawned entity\n    </span>.id();\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">2.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">spawn_batch</a>&lt;I&gt;(\n    &amp;mut self,\n    iter: I\n) -&gt; SpawnBatchIter&lt;'_, &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type core::iter::traits::collect::IntoIterator::IntoIter\">IntoIter</a>&gt;<span class=\"where fmt-newline\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>,\n    &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item\" title=\"type core::iter::traits::collect::IntoIterator::Item\">Item</a>: Bundle,</span></h4></section></summary><div class=\"docblock\"><p>Spawns a batch of entities with the same component [<code>Bundle</code>] type. Takes a given\n[<code>Bundle</code>] iterator and returns a corresponding [<code>Entity</code>] iterator.\nThis is more efficient than spawning entities and adding components to them individually,\nbut it is limited to spawning entities with the same [<code>Bundle</code>] type, whereas spawning\nindividually is more flexible.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Str(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Num(u32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entities = world.spawn_batch(<span class=\"macro\">vec!</span>[\n  (Str(<span class=\"string\">&quot;a&quot;</span>), Num(<span class=\"number\">0</span>)), <span class=\"comment\">// the first entity\n  </span>(Str(<span class=\"string\">&quot;b&quot;</span>), Num(<span class=\"number\">1</span>)), <span class=\"comment\">// the second entity\n</span>]).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(entities.len(), <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get</a>&lt;T&gt;(&amp;self, entity: Entity) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;T</a>&gt;<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Retrieves a reference to the given <code>entity</code>’s [<code>Component</code>] of the given type.\nReturns <code>None</code> if the <code>entity</code> does not have a [<code>Component</code>] of the given type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>position = world.get::&lt;Position&gt;(entity).unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_mut</a>&lt;T&gt;(&amp;mut self, entity: Entity) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Mut&lt;'_, T&gt;&gt;<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Retrieves a mutable reference to the given <code>entity</code>’s [<code>Component</code>] of the given type.\nReturns <code>None</code> if the <code>entity</code> does not have a [<code>Component</code>] of the given type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = world.get_mut::&lt;Position&gt;(entity).unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.despawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">despawn</a>(&amp;mut self, entity: Entity) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Despawns the given <code>entity</code>, if it exists. This will also remove all of the entity’s\n[<code>Component</code>]s. Returns <code>true</code> if the <code>entity</code> is successfully despawned and <code>false</code> if\nthe <code>entity</code> does not exist.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"macro\">assert!</span>(world.despawn(entity));\n<span class=\"macro\">assert!</span>(world.get_entity(entity).is_none());\n<span class=\"macro\">assert!</span>(world.get::&lt;Position&gt;(entity).is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_trackers\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">clear_trackers</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Clears the internal component tracker state.</p>\n<p>The world maintains some internal state about changed and removed components. This state\nis used by <a href=\"crate::removal_detection::RemovedComponents\"><code>RemovedComponents</code></a> to provide access to the entities that had a specific type\nof component removed since last tick.</p>\n<p>The state is also used for change detection when accessing components and resources outside\nof a system, for example via [<code>World::get_mut()</code>] or [<code>World::get_resource_mut()</code>].</p>\n<p>By clearing this internal state, the world “forgets” about those changes, allowing a new round\nof detection to be recorded.</p>\n<p>When using <code>bevy_ecs</code> as part of the full Bevy engine, this method is added as a system to the\nmain app, to run during <code>Last</code>, so you don’t need to call it manually. When using <code>bevy_ecs</code>\nas a separate standalone crate however, you need to call this manually.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// a whole new world\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"comment\">// you changed it\n</span><span class=\"kw\">let </span>entity = world.spawn(Transform::default()).id();\n\n<span class=\"comment\">// change is detected\n</span><span class=\"kw\">let </span>transform = world.get_mut::&lt;Transform&gt;(entity).unwrap();\n<span class=\"macro\">assert!</span>(transform.is_changed());\n\n<span class=\"comment\">// update the last change tick\n</span>world.clear_trackers();\n\n<span class=\"comment\">// change is no longer detected\n</span><span class=\"kw\">let </span>transform = world.get_mut::&lt;Transform&gt;(entity).unwrap();\n<span class=\"macro\">assert!</span>(!transform.is_changed());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.query\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">query</a>&lt;Q&gt;(&amp;mut self) -&gt; QueryState&lt;Q&gt;<span class=\"where fmt-newline\">where\n    Q: WorldQuery,</span></h4></section></summary><div class=\"docblock\"><p>Returns [<code>QueryState</code>] for the given [<code>WorldQuery</code>], which is used to efficiently\nrun queries on the [<code>World</code>] by storing and reusing the [<code>QueryState</code>].</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component, Debug, PartialEq)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Velocity {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entities = world.spawn_batch(<span class=\"macro\">vec!</span>[\n    (Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>}, Velocity { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">0.0 </span>}),\n    (Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>}, Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">1.0 </span>}),\n]).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>query = world.query::&lt;(<span class=\"kw-2\">&amp;mut </span>Position, <span class=\"kw-2\">&amp;</span>Velocity)&gt;();\n<span class=\"kw\">for </span>(<span class=\"kw-2\">mut </span>position, velocity) <span class=\"kw\">in </span>query.iter_mut(<span class=\"kw-2\">&amp;mut </span>world) {\n   position.x += velocity.x;\n   position.y += velocity.y;\n}\n\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;Position&gt;(entities[<span class=\"number\">0</span>]).unwrap(), <span class=\"kw-2\">&amp;</span>Position { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">0.0 </span>});\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;Position&gt;(entities[<span class=\"number\">1</span>]).unwrap(), <span class=\"kw-2\">&amp;</span>Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">1.0 </span>});</code></pre></div>\n<p>To iterate over entities in a deterministic order,\nsort the results of the query using the desired component as a key.\nNote that this requires fetching the whole result set from the query\nand allocation of a <a href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\"><code>Vec</code></a> to store it.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component, PartialEq, Eq, PartialOrd, Ord, Debug)]\n</span><span class=\"kw\">struct </span>Order(i32);\n<span class=\"attr\">#[derive(Component, PartialEq, Debug)]\n</span><span class=\"kw\">struct </span>Label(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>a = world.spawn((Order(<span class=\"number\">2</span>), Label(<span class=\"string\">&quot;second&quot;</span>))).id();\n<span class=\"kw\">let </span>b = world.spawn((Order(<span class=\"number\">3</span>), Label(<span class=\"string\">&quot;third&quot;</span>))).id();\n<span class=\"kw\">let </span>c = world.spawn((Order(<span class=\"number\">1</span>), Label(<span class=\"string\">&quot;first&quot;</span>))).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entities = world.query::&lt;(Entity, <span class=\"kw-2\">&amp;</span>Order, <span class=\"kw-2\">&amp;</span>Label)&gt;()\n    .iter(<span class=\"kw-2\">&amp;</span>world)\n    .collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"comment\">// Sort the query results by their `Order` component before comparing\n// to expected results. Query iteration order should not be relied on.\n</span>entities.sort_by_key(|e| e.<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(entities, <span class=\"macro\">vec!</span>[\n    (c, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">1</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;first&quot;</span>)),\n    (a, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">2</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;second&quot;</span>)),\n    (b, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">3</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;third&quot;</span>)),\n]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.query_filtered\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">query_filtered</a>&lt;Q, F&gt;(&amp;mut self) -&gt; QueryState&lt;Q, F&gt;<span class=\"where fmt-newline\">where\n    Q: WorldQuery,\n    F: ReadOnlyWorldQuery,</span></h4></section></summary><div class=\"docblock\"><p>Returns [<code>QueryState</code>] for the given filtered [<code>WorldQuery</code>], which is used to efficiently\nrun queries on the [<code>World</code>] by storing and reusing the [<code>QueryState</code>].</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World, query::With};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>A;\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>B;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>e1 = world.spawn(A).id();\n<span class=\"kw\">let </span>e2 = world.spawn((A, B)).id();\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>query = world.query_filtered::&lt;Entity, With&lt;B&gt;&gt;();\n<span class=\"kw\">let </span>matching_entities = query.iter(<span class=\"kw-2\">&amp;</span>world).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(matching_entities, <span class=\"macro\">vec!</span>[e2]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">removed</a>&lt;T&gt;(&amp;self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = Entity&gt;<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Returns an iterator of entities that had components of type <code>T</code> removed\nsince the last call to [<code>World::clear_trackers</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed_with_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">removed_with_id</a>(\n    &amp;self,\n    component_id: ComponentId\n) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = Entity&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator of entities that had components with the given <code>component_id</code> removed\nsince the last call to [<code>World::clear_trackers</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">init_resource</a>&lt;R&gt;(&amp;mut self) -&gt; ComponentId<span class=\"where fmt-newline\">where\n    R: Resource + FromWorld,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new resource and returns the [<code>ComponentId</code>] created for it.</p>\n<p>If the resource already exists, nothing happens.</p>\n<p>The value given by the [<code>FromWorld::from_world</code>] method will be used.\nNote that any resource with the <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\"><code>Default</code></a> trait automatically implements [<code>FromWorld</code>],\nand those default values will be here instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">insert_resource</a>&lt;R&gt;(&amp;mut self, value: R)<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Inserts a new resource with the given <code>value</code>.</p>\n<p>Resources are “unique” data of a given type.\nIf you insert a resource of a type that already exists,\nyou will overwrite any existing data.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">init_non_send_resource</a>&lt;R&gt;(&amp;mut self) -&gt; ComponentId<span class=\"where fmt-newline\">where\n    R: 'static + FromWorld,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new non-send resource and returns the [<code>ComponentId</code>] created for it.</p>\n<p>If the resource already exists, nothing happens.</p>\n<p>The value given by the [<code>FromWorld::from_world</code>] method will be used.\nNote that any resource with the <code>Default</code> trait automatically implements <code>FromWorld</code>,\nand those default values will be here instead.</p>\n<h5 id=\"panics-3\"><a href=\"#panics-3\">Panics</a></h5>\n<p>Panics if called from a thread other than the main thread.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">insert_non_send_resource</a>&lt;R&gt;(&amp;mut self, value: R)<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Inserts a new non-send resource with the given <code>value</code>.</p>\n<p><code>NonSend</code> resources cannot be sent across threads,\nand do not need the <code>Send + Sync</code> bounds.\nSystems with <code>NonSend</code> resources are always scheduled on the main thread.</p>\n<h5 id=\"panics-4\"><a href=\"#panics-4\">Panics</a></h5>\n<p>If a value is already present, this function will panic if called\nfrom a different thread than where the original value was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;R&gt;<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type and returns it, if it exists. Otherwise returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_non_send_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;R&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Removes a <code>!Send</code> resource from the world and returns it, if present.</p>\n<p><code>NonSend</code> resources cannot be sent across threads,\nand do not need the <code>Send + Sync</code> bounds.\nSystems with <code>NonSend</code> resources are always scheduled on the main thread.</p>\n<p>Returns <code>None</code> if a value was not previously present.</p>\n<h5 id=\"panics-5\"><a href=\"#panics-5\">Panics</a></h5>\n<p>If a value is present, this function will panic if called from a different\nthread than where the value was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">contains_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if a resource of type <code>R</code> exists. Otherwise returns <code>false</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains_non_send\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">contains_non_send</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if a resource of type <code>R</code> exists. Otherwise returns <code>false</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_resource_added\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_resource_added</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Return’s <code>true</code> if a resource of type <code>R</code> exists and was added since the world’s\n<a href=\"World::last_change_tick()\"><code>last_change_tick</code></a>. Otherwise, this return’s <code>false</code>.</p>\n<p>This means that:</p>\n<ul>\n<li>When called from an exclusive system, this will check for additions since the system last ran.</li>\n<li>When called elsewhere, this will check for additions since the last time that [<code>World::clear_trackers</code>]\nwas called.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_resource_changed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_resource_changed</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Return’s <code>true</code> if a resource of type <code>R</code> exists and was modified since the world’s\n<a href=\"World::last_change_tick()\"><code>last_change_tick</code></a>. Otherwise, this return’s <code>false</code>.</p>\n<p>This means that:</p>\n<ul>\n<li>When called from an exclusive system, this will check for changes since the system last ran.</li>\n<li>When called elsewhere, this will check for changes since the last time that [<code>World::clear_trackers</code>]\nwas called.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a><span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the resource of the given type</p>\n<h5 id=\"panics-6\"><a href=\"#panics-6\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"World::get_resource\"><code>get_resource</code></a> instead if you want to handle this case.</p>\n<p>If you want to instead insert a value if the resource does not exist,\nuse <a href=\"World::get_resource_or_insert_with\"><code>get_resource_or_insert_with</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; Mut&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of the given type</p>\n<h5 id=\"panics-7\"><a href=\"#panics-7\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"World::get_resource_mut\"><code>get_resource_mut</code></a> instead if you want to handle this case.</p>\n<p>If you want to instead insert a value if the resource does not exist,\nuse <a href=\"World::get_resource_or_insert_with\"><code>get_resource_or_insert_with</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a>&gt;<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the resource of the given type if it exists</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Mut&lt;'_, R&gt;&gt;<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of the given type if it exists</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_or_insert_with\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_resource_or_insert_with</a>&lt;R&gt;(\n    &amp;mut self,\n    func: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; R\n) -&gt; Mut&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of type <code>T</code> if it exists,\notherwise inserts the resource using the result of calling <code>func</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">non_send_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a><span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets an immutable reference to the non-send resource of the given type, if it exists.</p>\n<h5 id=\"panics-8\"><a href=\"#panics-8\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"World::get_non_send_resource\"><code>get_non_send_resource</code></a> instead if you want to handle this case.</p>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.non_send_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">non_send_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; Mut&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the non-send resource of the given type, if it exists.</p>\n<h5 id=\"panics-9\"><a href=\"#panics-9\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"World::get_non_send_resource_mut\"><code>get_non_send_resource_mut</code></a> instead if you want to handle this case.</p>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_non_send_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a>&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the non-send resource of the given type, if it exists.\nOtherwise returns <code>None</code>.</p>\n<h5 id=\"panics-10\"><a href=\"#panics-10\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_non_send_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Mut&lt;'_, R&gt;&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the non-send resource of the given type, if it exists.\nOtherwise returns <code>None</code>.</p>\n<h5 id=\"panics-11\"><a href=\"#panics-11\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_or_spawn_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">insert_or_spawn_batch</a>&lt;I, B&gt;(\n    &amp;mut self,\n    iter: I\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;Entity&gt;&gt;<span class=\"where fmt-newline\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>,\n    &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type core::iter::traits::collect::IntoIterator::IntoIter\">IntoIter</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = (Entity, B)&gt;,\n    B: Bundle,</span></h4></section></summary><div class=\"docblock\"><p>For a given batch of ([<code>Entity</code>], [<code>Bundle</code>]) pairs, either spawns each [<code>Entity</code>] with the given\nbundle (if the entity does not exist), or inserts the [<code>Bundle</code>] (if the entity already exists).\nThis is faster than doing equivalent operations one-by-one.\nReturns <code>Ok</code> if all entities were successfully inserted into or spawned. Otherwise it returns an <code>Err</code>\nwith a list of entities that could not be spawned or inserted into. A “spawn or insert” operation can\nonly fail if an [<code>Entity</code>] is passed in with an “invalid generation” that conflicts with an existing [<code>Entity</code>].</p>\n<h5 id=\"note-1\"><a href=\"#note-1\">Note</a></h5>\n<p>Spawning a specific <code>entity</code> value is rarely the right choice. Most apps should use [<code>World::spawn_batch</code>].\nThis method should generally only be used for sharing entities across apps, and only when they have a scheme\nworked out to share an ID space (which doesn’t happen by default).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{entity::Entity, world::World, component::Component};\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>A(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component, PartialEq, Debug)]\n</span><span class=\"kw\">struct </span>B(f32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>e0 = world.spawn_empty().id();\n<span class=\"kw\">let </span>e1 = world.spawn_empty().id();\nworld.insert_or_spawn_batch(<span class=\"macro\">vec!</span>[\n  (e0, (A(<span class=\"string\">&quot;a&quot;</span>), B(<span class=\"number\">0.0</span>))), <span class=\"comment\">// the first entity\n  </span>(e1, (A(<span class=\"string\">&quot;b&quot;</span>), B(<span class=\"number\">1.0</span>))), <span class=\"comment\">// the second entity\n</span>]);\n\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;B&gt;(e0), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>B(<span class=\"number\">0.0</span>)));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">resource_scope</a>&lt;R, U&gt;(\n    &amp;mut self,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut World, Mut&lt;'_, R&gt;) -&gt; U\n) -&gt; U<span class=\"where fmt-newline\">where\n    R: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Temporarily removes the requested resource from this [<code>World</code>], runs custom user code,\nthen re-adds the resource before returning.</p>\n<p>This enables safe simultaneous mutable access to both a resource and the rest of the [<code>World</code>].\nFor more complex access patterns, consider using <a href=\"crate::system::SystemState\"><code>SystemState</code></a>.</p>\n<h5 id=\"example\"><a href=\"#example\">Example</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"attr\">#[derive(Resource)]\n</span><span class=\"kw\">struct </span>A(u32);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>B(u32);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\nworld.insert_resource(A(<span class=\"number\">1</span>));\n<span class=\"kw\">let </span>entity = world.spawn(B(<span class=\"number\">1</span>)).id();\n\nworld.resource_scope(|world, <span class=\"kw-2\">mut </span>a: Mut&lt;A&gt;| {\n    <span class=\"kw\">let </span>b = world.get_mut::&lt;B&gt;(entity).unwrap();\n    a.<span class=\"number\">0 </span>+= b.<span class=\"number\">0</span>;\n});\n<span class=\"macro\">assert_eq!</span>(world.get_resource::&lt;A&gt;().unwrap().<span class=\"number\">0</span>, <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_event</a>&lt;E&gt;(&amp;mut self, event: E)<span class=\"where fmt-newline\">where\n    E: Event,</span></h4></section></summary><div class=\"docblock\"><p>Sends an [<code>Event</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event_default\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_event_default</a>&lt;E&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    E: Event + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a>,</span></h4></section></summary><div class=\"docblock\"><p>Sends the default value of the [<code>Event</code>] of type <code>E</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_event_batch</a>&lt;E&gt;(&amp;mut self, events: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&lt;Item = E&gt;)<span class=\"where fmt-newline\">where\n    E: Event,</span></h4></section></summary><div class=\"docblock\"><p>Sends a batch of [<code>Event</code>]s from an iterator.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">insert_resource_by_id</a>(\n    &amp;mut self,\n    component_id: ComponentId,\n    value: OwningPtr&lt;'_&gt;\n)</h4></section></summary><div class=\"docblock\"><p>Inserts a new resource with the given <code>value</code>. Will replace the value if it already existed.</p>\n<p><strong>You should prefer to use the typed API [<code>World::insert_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"safety-1\"><a href=\"#safety-1\">Safety</a></h5>\n<p>The value referenced by <code>value</code> must be valid for the given [<code>ComponentId</code>] of this world.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">insert_non_send_by_id</a>(\n    &amp;mut self,\n    component_id: ComponentId,\n    value: OwningPtr&lt;'_&gt;\n)</h4></section></summary><div class=\"docblock\"><p>Inserts a new <code>!Send</code> resource with the given <code>value</code>. Will replace the value if it already\nexisted.</p>\n<p><strong>You should prefer to use the typed API [<code>World::insert_non_send_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-12\"><a href=\"#panics-12\">Panics</a></h5>\n<p>If a value is already present, this function will panic if not called from the same\nthread that the original value was inserted from.</p>\n<h5 id=\"safety-2\"><a href=\"#safety-2\">Safety</a></h5>\n<p>The value referenced by <code>value</code> must be valid for the given [<code>ComponentId</code>] of this world.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.increment_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">increment_change_tick</a>(&amp;self) -&gt; Tick</h4></section></summary><div class=\"docblock\"><p>Increments the world’s current change tick and returns the old value.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">read_change_tick</a>(&amp;self) -&gt; Tick</h4></section></summary><div class=\"docblock\"><p>Reads the current change tick of this world.</p>\n<p>If you have exclusive (<code>&amp;mut</code>) access to the world, consider using <a href=\"Self::change_tick\"><code>change_tick()</code></a>,\nwhich is more efficient since it does not require atomic synchronization.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">change_tick</a>(&amp;mut self) -&gt; Tick</h4></section></summary><div class=\"docblock\"><p>Reads the current change tick of this world.</p>\n<p>This does the same thing as <a href=\"Self::read_change_tick\"><code>read_change_tick()</code></a>, only this method\nis more efficient since it does not require atomic synchronization.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">last_change_tick</a>(&amp;self) -&gt; Tick</h4></section></summary><div class=\"docblock\"><p>When called from within an exclusive system (a <a href=\"crate::system::System\"><code>System</code></a> that takes <code>&amp;mut World</code> as its first\nparameter), this method returns the [<code>Tick</code>] indicating the last time the exclusive system was run.</p>\n<p>Otherwise, this returns the <code>Tick</code> indicating the last time that [<code>World::clear_trackers</code>] was called.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_change_ticks\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">check_change_ticks</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Iterates all component change ticks and clamps any older than <a href=\"crate::change_detection::MAX_CHANGE_AGE\"><code>MAX_CHANGE_AGE</code></a>.\nThis prevents overflow and thus prevents false positives.</p>\n<p><strong>Note:</strong> Does nothing if the [<code>World</code>] counter has not been incremented at least [<code>CHECK_TICK_THRESHOLD</code>]\ntimes since the previous pass.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_all\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">clear_all</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Runs both <a href=\"Self::clear_entities\"><code>clear_entities</code></a> and <a href=\"Self::clear_resources\"><code>clear_resources</code></a>,\ninvalidating all [<code>Entity</code>] and resource fetches such as <a href=\"crate::system::Res\"><code>Res</code></a>, <a href=\"crate::system::ResMut\"><code>ResMut</code></a></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">clear_entities</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Despawns all entities in this [<code>World</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_resources\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">clear_resources</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Clears all resources in this [<code>World</code>].</p>\n<p><strong>Note:</strong> Any resource fetch to this [<code>World</code>] will fail unless they are re-initialized,\nincluding engine-internal resources that are only initialized on app/world construction.</p>\n<p>This can easily cause systems expecting certain resources to immediately start panicking.\nUse with caution.</p>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_resource_by_id</a>(&amp;self, component_id: ComponentId) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Ptr&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the resource with the id [<code>ComponentId</code>] if it exists.\nThe returned pointer must not be used to modify the resource, and must not be\ndereferenced after the immutable borrow of the [<code>World</code>] ends.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_resource_mut_by_id</a>(\n    &amp;mut self,\n    component_id: ComponentId\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;MutUntyped&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the resource with the id [<code>ComponentId</code>] if it exists.\nThe returned pointer may be used to modify the resource, as long as the mutable borrow\nof the [<code>World</code>] is still valid.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_resource_mut</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_non_send_by_id</a>(&amp;self, component_id: ComponentId) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Ptr&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a <code>!Send</code> resource to the resource with the id [<code>ComponentId</code>] if it exists.\nThe returned pointer must not be used to modify the resource, and must not be\ndereferenced after the immutable borrow of the [<code>World</code>] ends.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_non_send_mut_by_id</a>(\n    &amp;mut self,\n    component_id: ComponentId\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;MutUntyped&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a <code>!Send</code> resource to the resource with the id [<code>ComponentId</code>] if it exists.\nThe returned pointer may be used to modify the resource, as long as the mutable borrow\nof the [<code>World</code>] is still valid.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_resource_mut</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_resource_by_id</a>(&amp;mut self, component_id: ComponentId) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type, if it exists. Otherwise returns <code>None</code>.</p>\n<p><strong>You should prefer to use the typed API [<code>World::remove_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_non_send_by_id</a>(&amp;mut self, component_id: ComponentId) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type, if it exists. Otherwise returns <code>None</code>.</p>\n<p><strong>You should prefer to use the typed API [<code>World::remove_resource</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-2\"><a href=\"#panics-2\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_by_id</a>(\n    &amp;self,\n    entity: Entity,\n    component_id: ComponentId\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;Ptr&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an immutable untyped reference to the given <code>entity</code>’s [<code>Component</code>] of the given [<code>ComponentId</code>].\nReturns <code>None</code> if the <code>entity</code> does not have a [<code>Component</code>] of the given type.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_mut</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-3\"><a href=\"#panics-3\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">get_mut_by_id</a>(\n    &amp;mut self,\n    entity: Entity,\n    component_id: ComponentId\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;MutUntyped&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves a mutable untyped reference to the given <code>entity</code>’s [<code>Component</code>] of the given [<code>ComponentId</code>].\nReturns <code>None</code> if the <code>entity</code> does not have a [<code>Component</code>] of the given type.</p>\n<p><strong>You should prefer to use the typed API [<code>World::get_mut</code>] where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.add_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">add_schedule</a>(&amp;mut self, schedule: Schedule)</h4></section></summary><div class=\"docblock\"><p>Adds the specified [<code>Schedule</code>] to the world. The schedule can later be run\nby calling <a href=\"Self::run_schedule\"><code>.run_schedule(label)</code></a> or by directly\naccessing the [<code>Schedules</code>] resource.</p>\n<p>The <code>Schedules</code> resource will be initialized if it does not already exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_schedule_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_schedule_scope</a>&lt;R&gt;(\n    &amp;mut self,\n    label: impl ScheduleLabel,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut World, &amp;mut Schedule) -&gt; R\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;R, TryRunScheduleError&gt;</h4></section></summary><div class=\"docblock\"><p>Temporarily removes the schedule associated with <code>label</code> from the world,\nruns user code, and finally re-adds the schedule.\nThis returns a [<code>TryRunScheduleError</code>] if there is no schedule\nassociated with <code>label</code>.</p>\n<p>The [<code>Schedule</code>] is fetched from the [<code>Schedules</code>] resource of the world by its label,\nand system state is cached.</p>\n<p>For simple cases where you just need to call the schedule once,\nconsider using [<code>World::try_run_schedule</code>] instead.\nFor other use cases, see the example on [<code>World::schedule_scope</code>].</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.schedule_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">schedule_scope</a>&lt;R&gt;(\n    &amp;mut self,\n    label: impl ScheduleLabel,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut World, &amp;mut Schedule) -&gt; R\n) -&gt; R</h4></section></summary><div class=\"docblock\"><p>Temporarily removes the schedule associated with <code>label</code> from the world,\nruns user code, and finally re-adds the schedule.</p>\n<p>The [<code>Schedule</code>] is fetched from the [<code>Schedules</code>] resource of the world by its label,\nand system state is cached.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Run the schedule five times.\n</span>world.schedule_scope(MySchedule, |world, schedule| {\n    <span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">5 </span>{\n        schedule.run(world);\n    }\n});</code></pre></div>\n<p>For simple cases where you just need to call the schedule once,\nconsider using [<code>World::run_schedule</code>] instead.</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>If the requested schedule does not exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_run_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">try_run_schedule</a>(\n    &amp;mut self,\n    label: impl ScheduleLabel\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, TryRunScheduleError&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to run the [<code>Schedule</code>] associated with the <code>label</code> a single time,\nand returns a [<code>TryRunScheduleError</code>] if the schedule does not exist.</p>\n<p>The [<code>Schedule</code>] is fetched from the [<code>Schedules</code>] resource of the world by its label,\nand system state is cached.</p>\n<p>For simple testing use cases, call <a href=\"Schedule::run\"><code>Schedule::run(&amp;mut world)</code></a> instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.run_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">run_schedule</a>(&amp;mut self, label: impl ScheduleLabel)</h4></section></summary><div class=\"docblock\"><p>Runs the [<code>Schedule</code>] associated with the <code>label</code> a single time.</p>\n<p>The [<code>Schedule</code>] is fetched from the [<code>Schedules</code>] resource of the world by its label,\nand system state is cached.</p>\n<p>For simple testing use cases, call <a href=\"Schedule::run\"><code>Schedule::run(&amp;mut world)</code></a> instead.</p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>If the requested schedule does not exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allow_ambiguous_component\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">allow_ambiguous_component</a>&lt;T&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    T: Component,</span></h4></section></summary><div class=\"docblock\"><p>Ignore system order ambiguities caused by conflicts on [<code>Component</code>]s of type <code>T</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allow_ambiguous_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">allow_ambiguous_resource</a>&lt;T&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    T: Resource,</span></h4></section></summary><div class=\"docblock\"><p>Ignore system order ambiguities caused by conflicts on [<code>Resource</code>]s of type <code>T</code>.</p>\n</div></details></div></details>",0,"foliage::job::Container"],["<section id=\"impl-Sync-for-World\" class=\"impl\"><a href=\"#impl-Sync-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> for World</h3></section>","Sync","foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-World\" class=\"impl\"><a href=\"#impl-Default-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a> for World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; World</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html#tymethod.default\">Read more</a></div></details></div></details>","Default","foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-World\" class=\"impl\"><a href=\"#impl-Debug-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for World</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","foliage::job::Container"],["<section id=\"impl-Send-for-World\" class=\"impl\"><a href=\"#impl-Send-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> for World</h3></section>","Send","foliage::job::Container"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()