(function() {var type_impls = {
"foliage":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.register_system\" class=\"fn\">register_system</a>&lt;M, S&gt;(&amp;mut self, system: S) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\">SystemId</a><span class=\"where fmt-newline\">where\n    S: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.IntoSystem.html\" title=\"trait foliage::bevy_ecs::prelude::IntoSystem\">IntoSystem</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, M&gt; + 'static,</span></h4></section></summary><div class=\"docblock\"><p>Registers a system and returns a <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a> so it can later be called by <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.run_system\" title=\"method foliage::bevy_ecs::prelude::World::run_system\"><code>World::run_system</code></a>.</p>\n<p>It’s possible to register the same systems more than once, they’ll be stored separately.</p>\n<p>This is different from adding systems to a <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a>,\nbecause the <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a> that is returned can be used anywhere in the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> to run the associated system.\nThis allows for running systems in a pushed-based fashion.\nUsing a <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> is still preferred for most cases\ndue to its better performance and abillity to run non-conflicting systems simultaneously.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.register_boxed_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.register_boxed_system\" class=\"fn\">register_boxed_system</a>(\n    &amp;mut self,\n    system: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/boxed/struct.Box.html\" title=\"struct alloc::boxed::Box\">Box</a>&lt;dyn <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.System.html\" title=\"trait foliage::bevy_ecs::prelude::System\">System</a>&lt;Out = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, In = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;&gt;\n) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\">SystemId</a></h4></section></summary><div class=\"docblock\"><p>Similar to <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.register_system\" title=\"method foliage::bevy_ecs::prelude::World::register_system\"><code>Self::register_system</code></a>, but allows passing in a <a href=\"foliage/bevy_ecs/system/type.BoxedSystem.html\" title=\"type foliage::bevy_ecs::system::BoxedSystem\"><code>BoxedSystem</code></a>.</p>\n<p>This is useful if the <a href=\"foliage/bevy_ecs/prelude/trait.IntoSystem.html\" title=\"trait foliage::bevy_ecs::prelude::IntoSystem\"><code>IntoSystem</code></a> implementor has already been turned into a\n<a href=\"foliage/bevy_ecs/prelude/trait.System.html\" title=\"trait foliage::bevy_ecs::prelude::System\"><code>System</code></a> trait object and put in a <a href=\"https://doc.rust-lang.org/1.75.0/alloc/boxed/struct.Box.html\" title=\"struct alloc::boxed::Box\"><code>Box</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.remove_system\" class=\"fn\">remove_system</a>(\n    &amp;mut self,\n    id: <a class=\"struct\" href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\">SystemId</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/system/struct.RemovedSystem.html\" title=\"struct foliage::bevy_ecs::system::RemovedSystem\">RemovedSystem</a>, <a class=\"enum\" href=\"foliage/bevy_ecs/system/enum.RegisteredSystemError.html\" title=\"enum foliage::bevy_ecs::system::RegisteredSystemError\">RegisteredSystemError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes a registered system and returns the system, if it exists.\nAfter removing a system, the <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a> becomes invalid and attempting to use it afterwards will result in errors.\nRe-adding the removed system will register it on a new <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a>.</p>\n<p>If no system corresponds to the given <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a>, this method returns an error.\nSystems are also not allowed to remove themselves, this returns an error too.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.run_system\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.run_system\" class=\"fn\">run_system</a>(&amp;mut self, id: <a class=\"struct\" href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\">SystemId</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"foliage/bevy_ecs/system/enum.RegisteredSystemError.html\" title=\"enum foliage::bevy_ecs::system::RegisteredSystemError\">RegisteredSystemError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Run stored systems by their <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a>.\nBefore running a system, it must first be registered.\nThe method <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.register_system\" title=\"method foliage::bevy_ecs::prelude::World::register_system\"><code>World::register_system</code></a> stores a given system and returns a <a href=\"foliage/bevy_ecs/system/struct.SystemId.html\" title=\"struct foliage::bevy_ecs::system::SystemId\"><code>SystemId</code></a>.\nThis is different from <a href=\"foliage/bevy_ecs/system/trait.RunSystemOnce.html#method.run_system_once\" title=\"method foliage::bevy_ecs::system::RunSystemOnce::run_system_once\"><code>RunSystemOnce::run_system_once</code></a>,\nbecause it keeps local state between calls and change detection works correctly.</p>\n<h5 id=\"limitations\"><a href=\"#limitations\">Limitations</a></h5>\n<ul>\n<li>Stored systems cannot be chained: they can neither have an <a href=\"foliage/bevy_ecs/prelude/struct.In.html\" title=\"struct foliage::bevy_ecs::prelude::In\"><code>In</code></a> nor return any values.</li>\n<li>Stored systems cannot be recursive, they cannot call themselves through <a href=\"foliage/bevy_ecs/prelude/struct.Commands.html\" title=\"struct foliage::bevy_ecs::prelude::Commands\"><code>Commands::run_system</code></a>.</li>\n<li>Exclusive systems cannot be used.</li>\n</ul>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Resource, Default)]\n</span><span class=\"kw\">struct </span>Counter(u8);\n\n<span class=\"kw\">fn </span>increment(<span class=\"kw-2\">mut </span>counter: Local&lt;Counter&gt;) {\n   counter.<span class=\"number\">0 </span>+= <span class=\"number\">1</span>;\n   <span class=\"macro\">println!</span>(<span class=\"string\">&quot;{}&quot;</span>, counter.<span class=\"number\">0</span>);\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::default();\n<span class=\"kw\">let </span>counter_one = world.register_system(increment);\n<span class=\"kw\">let </span>counter_two = world.register_system(increment);\nworld.run_system(counter_one); <span class=\"comment\">// -&gt; 1\n</span>world.run_system(counter_one); <span class=\"comment\">// -&gt; 2\n</span>world.run_system(counter_two); <span class=\"comment\">// -&gt; 1</span></code></pre></div>\n<p>Change detection:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#[derive(Resource, Default)]\n</span><span class=\"kw\">struct </span>ChangeDetector;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::default();\nworld.init_resource::&lt;ChangeDetector&gt;();\n<span class=\"kw\">let </span>detector = world.register_system(|change_detector: ResMut&lt;ChangeDetector&gt;| {\n    <span class=\"kw\">if </span>change_detector.is_changed() {\n        <span class=\"macro\">println!</span>(<span class=\"string\">&quot;Something happened!&quot;</span>);\n    } <span class=\"kw\">else </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">&quot;Nothing happened.&quot;</span>);\n    }\n});\n\n<span class=\"comment\">// Resources are changed when they are first added\n</span><span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Something happened!\n</span><span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Nothing happened.\n</span>world.resource_mut::&lt;ChangeDetector&gt;().set_changed();\n<span class=\"kw\">let _ </span>= world.run_system(detector); <span class=\"comment\">// -&gt; Something happened!</span></code></pre></div>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.new\" class=\"fn\">new</a>() -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h4></section></summary><div class=\"docblock\"><p>Creates a new empty <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>.</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>If <a href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html#associatedconstant.MAX\" title=\"associated constant usize::MAX\"><code>usize::MAX</code></a> <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>s have been created.\nThis guarantee allows System Parameters to safely uniquely identify a <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>,\nsince its <a href=\"foliage/bevy_ecs/world/struct.WorldId.html\" title=\"struct foliage::bevy_ecs::world::WorldId\"><code>WorldId</code></a> is unique</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.id\" class=\"fn\">id</a>(&amp;self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/world/struct.WorldId.html\" title=\"struct foliage::bevy_ecs::world::WorldId\">WorldId</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>’s unique ID</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_unsafe_world_cell\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.as_unsafe_world_cell\" class=\"fn\">as_unsafe_world_cell</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/world/unsafe_world_cell/struct.UnsafeWorldCell.html\" title=\"struct foliage::bevy_ecs::world::unsafe_world_cell::UnsafeWorldCell\">UnsafeWorldCell</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <a href=\"foliage/bevy_ecs/world/unsafe_world_cell/struct.UnsafeWorldCell.html\" title=\"struct foliage::bevy_ecs::world::unsafe_world_cell::UnsafeWorldCell\"><code>UnsafeWorldCell</code></a> view with complete read+write access.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_unsafe_world_cell_readonly\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.as_unsafe_world_cell_readonly\" class=\"fn\">as_unsafe_world_cell_readonly</a>(&amp;self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/world/unsafe_world_cell/struct.UnsafeWorldCell.html\" title=\"struct foliage::bevy_ecs::world::unsafe_world_cell::UnsafeWorldCell\">UnsafeWorldCell</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new <a href=\"foliage/bevy_ecs/world/unsafe_world_cell/struct.UnsafeWorldCell.html\" title=\"struct foliage::bevy_ecs::world::unsafe_world_cell::UnsafeWorldCell\"><code>UnsafeWorldCell</code></a> view with only read access to everything.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.entities\" class=\"fn\">entities</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/entity/struct.Entities.html\" title=\"struct foliage::bevy_ecs::entity::Entities\">Entities</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/entity/struct.Entities.html\" title=\"struct foliage::bevy_ecs::entity::Entities\"><code>Entities</code></a> collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entities_mut\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.entities_mut\" class=\"fn\">entities_mut</a>(&amp;mut self) -&gt; &amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/entity/struct.Entities.html\" title=\"struct foliage::bevy_ecs::entity::Entities\">Entities</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/entity/struct.Entities.html\" title=\"struct foliage::bevy_ecs::entity::Entities\"><code>Entities</code></a> collection mutably.</p>\n<h5 id=\"safety\"><a href=\"#safety\">Safety</a></h5>\n<p>Mutable reference must not be used to put the <a href=\"foliage/bevy_ecs/entity/struct.Entities.html\" title=\"struct foliage::bevy_ecs::entity::Entities\"><code>Entities</code></a> data\nin an invalid state for this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.archetypes\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.archetypes\" class=\"fn\">archetypes</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/archetype/struct.Archetypes.html\" title=\"struct foliage::bevy_ecs::archetype::Archetypes\">Archetypes</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/archetype/struct.Archetypes.html\" title=\"struct foliage::bevy_ecs::archetype::Archetypes\"><code>Archetypes</code></a> collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.components\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.components\" class=\"fn\">components</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.Components.html\" title=\"struct foliage::bevy_ecs::component::Components\">Components</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/component/struct.Components.html\" title=\"struct foliage::bevy_ecs::component::Components\"><code>Components</code></a> collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.storages\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.storages\" class=\"fn\">storages</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/storage/struct.Storages.html\" title=\"struct foliage::bevy_ecs::storage::Storages\">Storages</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/storage/struct.Storages.html\" title=\"struct foliage::bevy_ecs::storage::Storages\"><code>Storages</code></a> collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.bundles\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.bundles\" class=\"fn\">bundles</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/bundle/struct.Bundles.html\" title=\"struct foliage::bevy_ecs::bundle::Bundles\">Bundles</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/bundle/struct.Bundles.html\" title=\"struct foliage::bevy_ecs::bundle::Bundles\"><code>Bundles</code></a> collection.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed_components\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.removed_components\" class=\"fn\">removed_components</a>(&amp;self) -&gt; &amp;<a class=\"struct\" href=\"foliage/bevy_ecs/removal_detection/struct.RemovedComponentEvents.html\" title=\"struct foliage::bevy_ecs::removal_detection::RemovedComponentEvents\">RemovedComponentEvents</a></h4></section></summary><div class=\"docblock\"><p>Retrieves this world’s <a href=\"foliage/bevy_ecs/removal_detection/struct.RemovedComponentEvents.html\" title=\"struct foliage::bevy_ecs::removal_detection::RemovedComponentEvents\"><code>RemovedComponentEvents</code></a> collection</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.cell\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.cell\" class=\"fn\">cell</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/world/struct.WorldCell.html\" title=\"struct foliage::bevy_ecs::world::WorldCell\">WorldCell</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves a <a href=\"foliage/bevy_ecs/world/struct.WorldCell.html\" title=\"struct foliage::bevy_ecs::world::WorldCell\"><code>WorldCell</code></a>, which safely enables multiple mutable World accesses at the same\ntime, provided those accesses do not conflict with each other.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_component\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.init_component\" class=\"fn\">init_component</a>&lt;T&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a><span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> type and returns the <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> created for it.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_component_with_descriptor\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.init_component_with_descriptor\" class=\"fn\">init_component_with_descriptor</a>(\n    &amp;mut self,\n    descriptor: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentDescriptor.html\" title=\"struct foliage::bevy_ecs::component::ComponentDescriptor\">ComponentDescriptor</a>\n) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a></h4></section></summary><div class=\"docblock\"><p>Initializes a new <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> type and returns the <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> created for it.</p>\n<p>This method differs from <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.init_component\" title=\"method foliage::bevy_ecs::prelude::World::init_component\"><code>World::init_component</code></a> in that it uses a <a href=\"foliage/bevy_ecs/component/struct.ComponentDescriptor.html\" title=\"struct foliage::bevy_ecs::component::ComponentDescriptor\"><code>ComponentDescriptor</code></a>\nto initialize the new component type instead of statically available type information. This\nenables the dynamic initialization of new component definitions at runtime for advanced use cases.</p>\n<p>While the option to initialize a component from a descriptor is useful in type-erased\ncontexts, the standard <code>World::init_component</code> function should always be used instead\nwhen type information is available at compile time.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.component_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.component_id\" class=\"fn\">component_id</a>&lt;T&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>&gt;<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Returns the <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> of the given <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> type <code>T</code>.</p>\n<p>The returned <code>ComponentId</code> is specific to the <code>World</code> instance\nit was retrieved from and should not be used with another <code>World</code> instance.</p>\n<p>Returns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>Component</code> type has not yet been initialized within\nthe <code>World</code> using <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.init_component\" title=\"method foliage::bevy_ecs::prelude::World::init_component\"><code>World::init_component</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>ComponentA;\n\n<span class=\"kw\">let </span>component_a_id = world.init_component::&lt;ComponentA&gt;();\n\n<span class=\"macro\">assert_eq!</span>(component_a_id, world.component_id::&lt;ComponentA&gt;().unwrap())</code></pre></div>\n<h5 id=\"see-also\"><a href=\"#see-also\">See also</a></h5>\n<ul>\n<li><a href=\"foliage/bevy_ecs/component/struct.Components.html#method.component_id\" title=\"method foliage::bevy_ecs::component::Components::component_id\"><code>Components::component_id()</code></a></li>\n<li><a href=\"foliage/bevy_ecs/component/struct.Components.html#method.get_id\" title=\"method foliage::bevy_ecs::component::Components::get_id\"><code>Components::get_id()</code></a></li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.entity\" class=\"fn\">entity</a>(&amp;self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\">EntityRef</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an <a href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\"><code>EntityRef</code></a> that exposes read-only operations for the given <code>entity</code>.\nThis will panic if the <code>entity</code> does not exist. Use <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_entity\" title=\"method foliage::bevy_ecs::prelude::World::get_entity\"><code>World::get_entity</code></a> if you want\nto check for entity existence instead of implicitly panic-ing.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.entity_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.entity_mut\" class=\"fn\">entity_mut</a>(&amp;mut self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\">EntityWorldMut</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an <a href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\"><code>EntityWorldMut</code></a> that exposes read and write operations for the given <code>entity</code>.\nThis will panic if the <code>entity</code> does not exist. Use <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_entity_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_entity_mut\"><code>World::get_entity_mut</code></a> if you want\nto check for entity existence instead of implicitly panic-ing.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entity_mut = world.entity_mut(entity);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = entity_mut.get_mut::&lt;Position&gt;().unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.many_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.many_entities\" class=\"fn\">many_entities</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\">EntityRef</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>Gets an <a href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\"><code>EntityRef</code></a> for multiple entities at once.</p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>If any entity does not exist in the world.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Getting multiple entities.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.many_entities([id1, id2]);</code></pre></div>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Trying to get a despawned entity will fail.\n</span>world.despawn(id2);\nworld.many_entities([id1, id2]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.many_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.many_entities_mut\" class=\"fn\">many_entities_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityMut\">EntityMut</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]</h4></section></summary><div class=\"docblock\"><p>Gets mutable access to multiple entities at once.</p>\n<h5 id=\"panics-2\"><a href=\"#panics-2\">Panics</a></h5>\n<p>If any entities do not exist in the world,\nor if the same entity is specified multiple times.</p>\n<h5 id=\"examples-1\"><a href=\"#examples-1\">Examples</a></h5>\n<p>Disjoint mutable access.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Disjoint mutable access.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.many_entities_mut([id1, id2]);</code></pre></div>\n<p>Trying to access the same entity multiple times will fail.</p>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code>world.many_entities_mut([id, id]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.inspect_entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.inspect_entity\" class=\"fn\">inspect_entity</a>(&amp;self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;&amp;<a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentInfo.html\" title=\"struct foliage::bevy_ecs::component::ComponentInfo\">ComponentInfo</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the components of an <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> through <a href=\"foliage/bevy_ecs/component/struct.ComponentInfo.html\" title=\"struct foliage::bevy_ecs::component::ComponentInfo\"><code>ComponentInfo</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_or_spawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_or_spawn\" class=\"fn\">get_or_spawn</a>(&amp;mut self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\">EntityWorldMut</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an <a href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\"><code>EntityWorldMut</code></a> for the given <code>entity</code> (if it exists) or spawns one if it doesn’t exist.\nThis will return <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> exists with a different generation.</p>\n<h5 id=\"note\"><a href=\"#note\">Note</a></h5>\n<p>Spawning a specific <code>entity</code> value is rarely the right choice. Most apps should favor <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.spawn\" title=\"method foliage::bevy_ecs::prelude::World::spawn\"><code>World::spawn</code></a>.\nThis method should generally only be used for sharing entities across apps, and only when they have a\nscheme worked out to share an ID space (which doesn’t happen by default).</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_entity\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_entity\" class=\"fn\">get_entity</a>(&amp;self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\">EntityRef</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an <a href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\"><code>EntityRef</code></a> that exposes read-only operations for the given <code>entity</code>.\nReturns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> does not exist.\nInstead of unwrapping the value returned from this function, prefer <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.entity\" title=\"method foliage::bevy_ecs::prelude::World::entity\"><code>World::entity</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>entity_ref = world.get_entity(entity).unwrap();\n<span class=\"kw\">let </span>position = entity_ref.get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_many_entities\" class=\"fn\">get_many_entities</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;self,\n    entities: [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;[<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\">EntityRef</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>], <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Gets an <a href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\"><code>EntityRef</code></a> for multiple entities at once.</p>\n<h5 id=\"errors\"><a href=\"#errors\">Errors</a></h5>\n<p>If any entity does not exist in the world.</p>\n<h5 id=\"examples-2\"><a href=\"#examples-2\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Getting multiple entities.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.get_many_entities([id1, id2]).unwrap();\n\n<span class=\"comment\">// Trying to get a despawned entity will fail.\n</span>world.despawn(id2);\n<span class=\"macro\">assert!</span>(world.get_many_entities([id1, id2]).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.iter_entities\" class=\"fn\">iter_entities</a>(&amp;self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityRef.html\" title=\"struct foliage::bevy_ecs::prelude::EntityRef\">EntityRef</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> iterator of current entities.</p>\n<p>This is useful in contexts where you only have read-only access to the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.iter_entities_mut\" class=\"fn\">iter_entities_mut</a>(&amp;mut self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityMut\">EntityMut</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable iterator over all entities in the <code>World</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_entity_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_entity_mut\" class=\"fn\">get_entity_mut</a>(&amp;mut self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\">EntityWorldMut</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an <a href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\"><code>EntityWorldMut</code></a> that exposes read and write operations for the given <code>entity</code>.\nReturns <a href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html#variant.None\" title=\"variant core::option::Option::None\"><code>None</code></a> if the <code>entity</code> does not exist.\nInstead of unwrapping the value returned from this function, prefer <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.entity_mut\" title=\"method foliage::bevy_ecs::prelude::World::entity_mut\"><code>World::entity_mut</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entity_mut = world.get_entity_mut(entity).unwrap();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = entity_mut.get_mut::&lt;Position&gt;().unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_entities_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_many_entities_mut\" class=\"fn\">get_many_entities_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    entities: [<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>]\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;[<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityMut\">EntityMut</a>&lt;'_&gt;; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.array.html\">N</a>], <a class=\"enum\" href=\"foliage/bevy_ecs/query/enum.QueryEntityError.html\" title=\"enum foliage::bevy_ecs::query::QueryEntityError\">QueryEntityError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Gets mutable access to multiple entities.</p>\n<h5 id=\"errors-1\"><a href=\"#errors-1\">Errors</a></h5>\n<p>If any entities do not exist in the world,\nor if the same entity is specified multiple times.</p>\n<h5 id=\"examples-3\"><a href=\"#examples-3\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Disjoint mutable access.\n</span><span class=\"kw\">let </span>[entity1, entity2] = world.get_many_entities_mut([id1, id2]).unwrap();\n\n<span class=\"comment\">// Trying to access the same entity multiple times will fail.\n</span><span class=\"macro\">assert!</span>(world.get_many_entities_mut([id1, id1]).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_empty\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.spawn_empty\" class=\"fn\">spawn_empty</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\">EntityWorldMut</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Spawns a new <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> and returns a corresponding <a href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\"><code>EntityWorldMut</code></a>, which can be used\nto add components to the entity or retrieve its id.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Label(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Num(u32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn_empty()\n    .insert(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}) <span class=\"comment\">// add a single component\n    </span>.insert((Num(<span class=\"number\">1</span>), Label(<span class=\"string\">&quot;hello&quot;</span>))) <span class=\"comment\">// add a bundle of components\n    </span>.id();\n\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.spawn\" class=\"fn\">spawn</a>&lt;B&gt;(&amp;mut self, bundle: B) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\">EntityWorldMut</a>&lt;'_&gt;<span class=\"where fmt-newline\">where\n    B: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\">Bundle</a>,</span></h4></section></summary><div class=\"docblock\"><p>Spawns a new <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> with a given <a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a> of <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">components</a> and returns\na corresponding <a href=\"foliage/bevy_ecs/prelude/struct.EntityWorldMut.html\" title=\"struct foliage::bevy_ecs::prelude::EntityWorldMut\"><code>EntityWorldMut</code></a>, which can be used to add components to the entity or\nretrieve its id.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{bundle::Bundle, component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Velocity {\n    x: f32,\n    y: f32,\n};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Name(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n\n<span class=\"attr\">#[derive(Bundle)]\n</span><span class=\"kw\">struct </span>PhysicsBundle {\n    position: Position,\n    velocity: Velocity,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"comment\">// `spawn` can accept a single component:\n</span>world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>});\n<span class=\"comment\">// It can also accept a tuple of components:\n</span>world.spawn((\n    Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>},\n    Velocity { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">1.0 </span>},\n));\n<span class=\"comment\">// Or it can accept a pre-defined Bundle of components:\n</span>world.spawn(PhysicsBundle {\n    position: Position { x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0 </span>},\n    velocity: Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">4.0 </span>},\n});\n\n<span class=\"kw\">let </span>entity = world\n    <span class=\"comment\">// Tuples can also mix Bundles and Components\n    </span>.spawn((\n        PhysicsBundle {\n            position: Position { x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0 </span>},\n            velocity: Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">4.0 </span>},\n        },\n        Name(<span class=\"string\">&quot;Elaina Proctor&quot;</span>),\n    ))\n    <span class=\"comment\">// Calling id() will return the unique identifier for the spawned entity\n    </span>.id();\n<span class=\"kw\">let </span>position = world.entity(entity).get::&lt;Position&gt;().unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">2.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.spawn_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.spawn_batch\" class=\"fn\">spawn_batch</a>&lt;I&gt;(\n    &amp;mut self,\n    iter: I\n) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/world/struct.SpawnBatchIter.html\" title=\"struct foliage::bevy_ecs::world::SpawnBatchIter\">SpawnBatchIter</a>&lt;'_, &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type core::iter::traits::collect::IntoIterator::IntoIter\">IntoIter</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"SpawnBatchIter&lt;&#39;_, &lt;I as IntoIterator&gt;::IntoIter&gt;\">ⓘ</a><span class=\"where fmt-newline\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>,\n    &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item\" title=\"type core::iter::traits::collect::IntoIterator::Item\">Item</a>: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\">Bundle</a>,</span></h4></section></summary><div class=\"docblock\"><p>Spawns a batch of entities with the same component <a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a> type. Takes a given\n<a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a> iterator and returns a corresponding <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> iterator.\nThis is more efficient than spawning entities and adding components to them individually,\nbut it is limited to spawning entities with the same <a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a> type, whereas spawning\nindividually is more flexible.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Str(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Num(u32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entities = world.spawn_batch(<span class=\"macro\">vec!</span>[\n  (Str(<span class=\"string\">&quot;a&quot;</span>), Num(<span class=\"number\">0</span>)), <span class=\"comment\">// the first entity\n  </span>(Str(<span class=\"string\">&quot;b&quot;</span>), Num(<span class=\"number\">1</span>)), <span class=\"comment\">// the second entity\n</span>]).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(entities.len(), <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get\" class=\"fn\">get</a>&lt;T&gt;(&amp;self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;T</a>&gt;<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Retrieves a reference to the given <code>entity</code>’s <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.\nReturns <code>None</code> if the <code>entity</code> does not have a <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span>position = world.get::&lt;Position&gt;(entity).unwrap();\n<span class=\"macro\">assert_eq!</span>(position.x, <span class=\"number\">0.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_mut\" class=\"fn\">get_mut</a>&lt;T&gt;(&amp;mut self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, T&gt;&gt;<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Retrieves a mutable reference to the given <code>entity</code>’s <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.\nReturns <code>None</code> if the <code>entity</code> does not have a <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>position = world.get_mut::&lt;Position&gt;(entity).unwrap();\nposition.x = <span class=\"number\">1.0</span>;</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.despawn\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.despawn\" class=\"fn\">despawn</a>(&amp;mut self, entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Despawns the given <code>entity</code>, if it exists. This will also remove all of the entity’s\n<a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a>s. Returns <code>true</code> if the <code>entity</code> is successfully despawned and <code>false</code> if\nthe <code>entity</code> does not exist.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, world::World};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entity = world.spawn(Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0 </span>}).id();\n<span class=\"macro\">assert!</span>(world.despawn(entity));\n<span class=\"macro\">assert!</span>(world.get_entity(entity).is_none());\n<span class=\"macro\">assert!</span>(world.get::&lt;Position&gt;(entity).is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_trackers\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.clear_trackers\" class=\"fn\">clear_trackers</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Clears the internal component tracker state.</p>\n<p>The world maintains some internal state about changed and removed components. This state\nis used by <a href=\"foliage/bevy_ecs/prelude/struct.RemovedComponents.html\" title=\"struct foliage::bevy_ecs::prelude::RemovedComponents\"><code>RemovedComponents</code></a> to provide access to the entities that had a specific type\nof component removed since last tick.</p>\n<p>The state is also used for change detection when accessing components and resources outside\nof a system, for example via <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_mut\"><code>World::get_mut()</code></a> or <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_mut\"><code>World::get_resource_mut()</code></a>.</p>\n<p>By clearing this internal state, the world “forgets” about those changes, allowing a new round\nof detection to be recorded.</p>\n<p>When using <code>bevy_ecs</code> as part of the full Bevy engine, this method is added as a system to the\nmain app, to run during <code>Last</code>, so you don’t need to call it manually. When using <code>bevy_ecs</code>\nas a separate standalone crate however, you need to call this manually.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// a whole new world\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n\n<span class=\"comment\">// you changed it\n</span><span class=\"kw\">let </span>entity = world.spawn(Transform::default()).id();\n\n<span class=\"comment\">// change is detected\n</span><span class=\"kw\">let </span>transform = world.get_mut::&lt;Transform&gt;(entity).unwrap();\n<span class=\"macro\">assert!</span>(transform.is_changed());\n\n<span class=\"comment\">// update the last change tick\n</span>world.clear_trackers();\n\n<span class=\"comment\">// change is no longer detected\n</span><span class=\"kw\">let </span>transform = world.get_mut::&lt;Transform&gt;(entity).unwrap();\n<span class=\"macro\">assert!</span>(!transform.is_changed());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.query\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.query\" class=\"fn\">query</a>&lt;Q&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\">QueryState</a>&lt;Q&gt;<span class=\"where fmt-newline\">where\n    Q: <a class=\"trait\" href=\"foliage/bevy_ecs/query/trait.WorldQuery.html\" title=\"trait foliage::bevy_ecs::query::WorldQuery\">WorldQuery</a>,</span></h4></section></summary><div class=\"docblock\"><p>Returns <a href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\"><code>QueryState</code></a> for the given <a href=\"foliage/bevy_ecs/query/trait.WorldQuery.html\" title=\"trait foliage::bevy_ecs::query::WorldQuery\"><code>WorldQuery</code></a>, which is used to efficiently\nrun queries on the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> by storing and reusing the <a href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\"><code>QueryState</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component, Debug, PartialEq)]\n</span><span class=\"kw\">struct </span>Position {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>Velocity {\n  x: f32,\n  y: f32,\n}\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>entities = world.spawn_batch(<span class=\"macro\">vec!</span>[\n    (Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>}, Velocity { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">0.0 </span>}),\n    (Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>}, Velocity { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">1.0 </span>}),\n]).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>query = world.query::&lt;(<span class=\"kw-2\">&amp;mut </span>Position, <span class=\"kw-2\">&amp;</span>Velocity)&gt;();\n<span class=\"kw\">for </span>(<span class=\"kw-2\">mut </span>position, velocity) <span class=\"kw\">in </span>query.iter_mut(<span class=\"kw-2\">&amp;mut </span>world) {\n   position.x += velocity.x;\n   position.y += velocity.y;\n}\n\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;Position&gt;(entities[<span class=\"number\">0</span>]).unwrap(), <span class=\"kw-2\">&amp;</span>Position { x: <span class=\"number\">1.0</span>, y: <span class=\"number\">0.0 </span>});\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;Position&gt;(entities[<span class=\"number\">1</span>]).unwrap(), <span class=\"kw-2\">&amp;</span>Position { x: <span class=\"number\">0.0</span>, y: <span class=\"number\">1.0 </span>});</code></pre></div>\n<p>To iterate over entities in a deterministic order,\nsort the results of the query using the desired component as a key.\nNote that this requires fetching the whole result set from the query\nand allocation of a <a href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\"><code>Vec</code></a> to store it.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World};\n\n<span class=\"attr\">#[derive(Component, PartialEq, Eq, PartialOrd, Ord, Debug)]\n</span><span class=\"kw\">struct </span>Order(i32);\n<span class=\"attr\">#[derive(Component, PartialEq, Debug)]\n</span><span class=\"kw\">struct </span>Label(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>a = world.spawn((Order(<span class=\"number\">2</span>), Label(<span class=\"string\">&quot;second&quot;</span>))).id();\n<span class=\"kw\">let </span>b = world.spawn((Order(<span class=\"number\">3</span>), Label(<span class=\"string\">&quot;third&quot;</span>))).id();\n<span class=\"kw\">let </span>c = world.spawn((Order(<span class=\"number\">1</span>), Label(<span class=\"string\">&quot;first&quot;</span>))).id();\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>entities = world.query::&lt;(Entity, <span class=\"kw-2\">&amp;</span>Order, <span class=\"kw-2\">&amp;</span>Label)&gt;()\n    .iter(<span class=\"kw-2\">&amp;</span>world)\n    .collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"comment\">// Sort the query results by their `Order` component before comparing\n// to expected results. Query iteration order should not be relied on.\n</span>entities.sort_by_key(|e| e.<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(entities, <span class=\"macro\">vec!</span>[\n    (c, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">1</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;first&quot;</span>)),\n    (a, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">2</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;second&quot;</span>)),\n    (b, <span class=\"kw-2\">&amp;</span>Order(<span class=\"number\">3</span>), <span class=\"kw-2\">&amp;</span>Label(<span class=\"string\">&quot;third&quot;</span>)),\n]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.query_filtered\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.query_filtered\" class=\"fn\">query_filtered</a>&lt;Q, F&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\">QueryState</a>&lt;Q, F&gt;<span class=\"where fmt-newline\">where\n    Q: <a class=\"trait\" href=\"foliage/bevy_ecs/query/trait.WorldQuery.html\" title=\"trait foliage::bevy_ecs::query::WorldQuery\">WorldQuery</a>,\n    F: <a class=\"trait\" href=\"foliage/bevy_ecs/query/trait.ReadOnlyWorldQuery.html\" title=\"trait foliage::bevy_ecs::query::ReadOnlyWorldQuery\">ReadOnlyWorldQuery</a>,</span></h4></section></summary><div class=\"docblock\"><p>Returns <a href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\"><code>QueryState</code></a> for the given filtered <a href=\"foliage/bevy_ecs/query/trait.WorldQuery.html\" title=\"trait foliage::bevy_ecs::query::WorldQuery\"><code>WorldQuery</code></a>, which is used to efficiently\nrun queries on the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> by storing and reusing the <a href=\"foliage/bevy_ecs/prelude/struct.QueryState.html\" title=\"struct foliage::bevy_ecs::prelude::QueryState\"><code>QueryState</code></a>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{component::Component, entity::Entity, world::World, query::With};\n\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>A;\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>B;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>e1 = world.spawn(A).id();\n<span class=\"kw\">let </span>e2 = world.spawn((A, B)).id();\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>query = world.query_filtered::&lt;Entity, With&lt;B&gt;&gt;();\n<span class=\"kw\">let </span>matching_entities = query.iter(<span class=\"kw-2\">&amp;</span>world).collect::&lt;Vec&lt;Entity&gt;&gt;();\n\n<span class=\"macro\">assert_eq!</span>(matching_entities, <span class=\"macro\">vec!</span>[e2]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.removed\" class=\"fn\">removed</a>&lt;T&gt;(&amp;self) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>&gt;<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Returns an iterator of entities that had components of type <code>T</code> removed\nsince the last call to <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_trackers\" title=\"method foliage::bevy_ecs::prelude::World::clear_trackers\"><code>World::clear_trackers</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.removed_with_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.removed_with_id\" class=\"fn\">removed_with_id</a>(\n    &amp;self,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>\n) -&gt; impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator of entities that had components with the given <code>component_id</code> removed\nsince the last call to <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_trackers\" title=\"method foliage::bevy_ecs::prelude::World::clear_trackers\"><code>World::clear_trackers</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.init_resource\" class=\"fn\">init_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a><span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a> + <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.FromWorld.html\" title=\"trait foliage::bevy_ecs::prelude::FromWorld\">FromWorld</a>,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new resource and returns the <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> created for it.</p>\n<p>If the resource already exists, nothing happens.</p>\n<p>The value given by the <a href=\"foliage/bevy_ecs/prelude/trait.FromWorld.html#tymethod.from_world\" title=\"associated function foliage::bevy_ecs::prelude::FromWorld::from_world\"><code>FromWorld::from_world</code></a> method will be used.\nNote that any resource with the <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\"><code>Default</code></a> trait automatically implements <a href=\"foliage/bevy_ecs/prelude/trait.FromWorld.html\" title=\"trait foliage::bevy_ecs::prelude::FromWorld\"><code>FromWorld</code></a>,\nand those default values will be here instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.insert_resource\" class=\"fn\">insert_resource</a>&lt;R&gt;(&amp;mut self, value: R)<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Inserts a new resource with the given <code>value</code>.</p>\n<p>Resources are “unique” data of a given type.\nIf you insert a resource of a type that already exists,\nyou will overwrite any existing data.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.init_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.init_non_send_resource\" class=\"fn\">init_non_send_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a><span class=\"where fmt-newline\">where\n    R: 'static + <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.FromWorld.html\" title=\"trait foliage::bevy_ecs::prelude::FromWorld\">FromWorld</a>,</span></h4></section></summary><div class=\"docblock\"><p>Initializes a new non-send resource and returns the <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> created for it.</p>\n<p>If the resource already exists, nothing happens.</p>\n<p>The value given by the <a href=\"foliage/bevy_ecs/prelude/trait.FromWorld.html#tymethod.from_world\" title=\"associated function foliage::bevy_ecs::prelude::FromWorld::from_world\"><code>FromWorld::from_world</code></a> method will be used.\nNote that any resource with the <code>Default</code> trait automatically implements <code>FromWorld</code>,\nand those default values will be here instead.</p>\n<h5 id=\"panics-3\"><a href=\"#panics-3\">Panics</a></h5>\n<p>Panics if called from a thread other than the main thread.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.insert_non_send_resource\" class=\"fn\">insert_non_send_resource</a>&lt;R&gt;(&amp;mut self, value: R)<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Inserts a new non-send resource with the given <code>value</code>.</p>\n<p><code>NonSend</code> resources cannot be sent across threads,\nand do not need the <code>Send + Sync</code> bounds.\nSystems with <code>NonSend</code> resources are always scheduled on the main thread.</p>\n<h5 id=\"panics-4\"><a href=\"#panics-4\">Panics</a></h5>\n<p>If a value is already present, this function will panic if called\nfrom a different thread than where the original value was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.remove_resource\" class=\"fn\">remove_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;R&gt;<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type and returns it, if it exists. Otherwise returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.remove_non_send_resource\" class=\"fn\">remove_non_send_resource</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;R&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Removes a <code>!Send</code> resource from the world and returns it, if present.</p>\n<p><code>NonSend</code> resources cannot be sent across threads,\nand do not need the <code>Send + Sync</code> bounds.\nSystems with <code>NonSend</code> resources are always scheduled on the main thread.</p>\n<p>Returns <code>None</code> if a value was not previously present.</p>\n<h5 id=\"panics-5\"><a href=\"#panics-5\">Panics</a></h5>\n<p>If a value is present, this function will panic if called from a different\nthread than where the value was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.contains_resource\" class=\"fn\">contains_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if a resource of type <code>R</code> exists. Otherwise returns <code>false</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains_non_send\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.contains_non_send\" class=\"fn\">contains_non_send</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if a resource of type <code>R</code> exists. Otherwise returns <code>false</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_resource_added\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.is_resource_added\" class=\"fn\">is_resource_added</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Return’s <code>true</code> if a resource of type <code>R</code> exists and was added since the world’s\n<a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.last_change_tick\" title=\"method foliage::bevy_ecs::prelude::World::last_change_tick\"><code>last_change_tick</code></a>. Otherwise, this return’s <code>false</code>.</p>\n<p>This means that:</p>\n<ul>\n<li>When called from an exclusive system, this will check for additions since the system last ran.</li>\n<li>When called elsewhere, this will check for additions since the last time that <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_trackers\" title=\"method foliage::bevy_ecs::prelude::World::clear_trackers\"><code>World::clear_trackers</code></a>\nwas called.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_resource_changed\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.is_resource_changed\" class=\"fn\">is_resource_changed</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.bool.html\">bool</a><span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Return’s <code>true</code> if a resource of type <code>R</code> exists and was modified since the world’s\n<a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.last_change_tick\" title=\"method foliage::bevy_ecs::prelude::World::last_change_tick\"><code>last_change_tick</code></a>. Otherwise, this return’s <code>false</code>.</p>\n<p>This means that:</p>\n<ul>\n<li>When called from an exclusive system, this will check for changes since the system last ran.</li>\n<li>When called elsewhere, this will check for changes since the last time that <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_trackers\" title=\"method foliage::bevy_ecs::prelude::World::clear_trackers\"><code>World::clear_trackers</code></a>\nwas called.</li>\n</ul>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.resource\" class=\"fn\">resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a><span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the resource of the given type</p>\n<h5 id=\"panics-6\"><a href=\"#panics-6\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource\" title=\"method foliage::bevy_ecs::prelude::World::get_resource\"><code>get_resource</code></a> instead if you want to handle this case.</p>\n<p>If you want to instead insert a value if the resource does not exist,\nuse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_or_insert_with\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_or_insert_with\"><code>get_resource_or_insert_with</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.resource_mut\" class=\"fn\">resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of the given type</p>\n<h5 id=\"panics-7\"><a href=\"#panics-7\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_mut\"><code>get_resource_mut</code></a> instead if you want to handle this case.</p>\n<p>If you want to instead insert a value if the resource does not exist,\nuse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_or_insert_with\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_or_insert_with\"><code>get_resource_or_insert_with</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_resource\" class=\"fn\">get_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a>&gt;<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the resource of the given type if it exists</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_resource_mut\" class=\"fn\">get_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;&gt;<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of the given type if it exists</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_or_insert_with\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_resource_or_insert_with\" class=\"fn\">get_resource_or_insert_with</a>&lt;R&gt;(\n    &amp;mut self,\n    func: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>() -&gt; R\n) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the resource of type <code>T</code> if it exists,\notherwise inserts the resource using the result of calling <code>func</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.non_send_resource\" class=\"fn\">non_send_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a><span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets an immutable reference to the non-send resource of the given type, if it exists.</p>\n<h5 id=\"panics-8\"><a href=\"#panics-8\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_non_send_resource\" title=\"method foliage::bevy_ecs::prelude::World::get_non_send_resource\"><code>get_non_send_resource</code></a> instead if you want to handle this case.</p>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.non_send_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.non_send_resource_mut\" class=\"fn\">non_send_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the non-send resource of the given type, if it exists.</p>\n<h5 id=\"panics-9\"><a href=\"#panics-9\">Panics</a></h5>\n<p>Panics if the resource does not exist.\nUse <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_non_send_resource_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_non_send_resource_mut\"><code>get_non_send_resource_mut</code></a> instead if you want to handle this case.</p>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_non_send_resource\" class=\"fn\">get_non_send_resource</a>&lt;R&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.reference.html\">&amp;R</a>&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a reference to the non-send resource of the given type, if it exists.\nOtherwise returns <code>None</code>.</p>\n<h5 id=\"panics-10\"><a href=\"#panics-10\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_resource_mut\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_non_send_resource_mut\" class=\"fn\">get_non_send_resource_mut</a>&lt;R&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;&gt;<span class=\"where fmt-newline\">where\n    R: 'static,</span></h4></section></summary><div class=\"docblock\"><p>Gets a mutable reference to the non-send resource of the given type, if it exists.\nOtherwise returns <code>None</code>.</p>\n<h5 id=\"panics-11\"><a href=\"#panics-11\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_or_spawn_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.insert_or_spawn_batch\" class=\"fn\">insert_or_spawn_batch</a>&lt;I, B&gt;(\n    &amp;mut self,\n    iter: I\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>&gt;&gt;<span class=\"where fmt-newline\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>,\n    &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter\" title=\"type core::iter::traits::collect::IntoIterator::IntoIter\">IntoIter</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = (<a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>, B)&gt;,\n    B: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\">Bundle</a>,</span></h4></section></summary><div class=\"docblock\"><p>For a given batch of (<a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a>, <a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a>) pairs, either spawns each <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> with the given\nbundle (if the entity does not exist), or inserts the <a href=\"foliage/bevy_ecs/prelude/trait.Bundle.html\" title=\"trait foliage::bevy_ecs::prelude::Bundle\"><code>Bundle</code></a> (if the entity already exists).\nThis is faster than doing equivalent operations one-by-one.\nReturns <code>Ok</code> if all entities were successfully inserted into or spawned. Otherwise it returns an <code>Err</code>\nwith a list of entities that could not be spawned or inserted into. A “spawn or insert” operation can\nonly fail if an <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> is passed in with an “invalid generation” that conflicts with an existing <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a>.</p>\n<h5 id=\"note-1\"><a href=\"#note-1\">Note</a></h5>\n<p>Spawning a specific <code>entity</code> value is rarely the right choice. Most apps should use <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.spawn_batch\" title=\"method foliage::bevy_ecs::prelude::World::spawn_batch\"><code>World::spawn_batch</code></a>.\nThis method should generally only be used for sharing entities across apps, and only when they have a scheme\nworked out to share an ID space (which doesn’t happen by default).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::{entity::Entity, world::World, component::Component};\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>A(<span class=\"kw-2\">&amp;</span><span class=\"lifetime\">&#39;static </span>str);\n<span class=\"attr\">#[derive(Component, PartialEq, Debug)]\n</span><span class=\"kw\">struct </span>B(f32);\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\n<span class=\"kw\">let </span>e0 = world.spawn_empty().id();\n<span class=\"kw\">let </span>e1 = world.spawn_empty().id();\nworld.insert_or_spawn_batch(<span class=\"macro\">vec!</span>[\n  (e0, (A(<span class=\"string\">&quot;a&quot;</span>), B(<span class=\"number\">0.0</span>))), <span class=\"comment\">// the first entity\n  </span>(e1, (A(<span class=\"string\">&quot;b&quot;</span>), B(<span class=\"number\">1.0</span>))), <span class=\"comment\">// the second entity\n</span>]);\n\n<span class=\"macro\">assert_eq!</span>(world.get::&lt;B&gt;(e0), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>B(<span class=\"number\">0.0</span>)));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.resource_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.resource_scope\" class=\"fn\">resource_scope</a>&lt;R, U&gt;(\n    &amp;mut self,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a>, <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Mut.html\" title=\"struct foliage::bevy_ecs::prelude::Mut\">Mut</a>&lt;'_, R&gt;) -&gt; U\n) -&gt; U<span class=\"where fmt-newline\">where\n    R: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Temporarily removes the requested resource from this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>, runs custom user code,\nthen re-adds the resource before returning.</p>\n<p>This enables safe simultaneous mutable access to both a resource and the rest of the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>.\nFor more complex access patterns, consider using <a href=\"foliage/bevy_ecs/system/struct.SystemState.html\" title=\"struct foliage::bevy_ecs::system::SystemState\"><code>SystemState</code></a>.</p>\n<h5 id=\"example\"><a href=\"#example\">Example</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>bevy_ecs::prelude::<span class=\"kw-2\">*</span>;\n<span class=\"attr\">#[derive(Resource)]\n</span><span class=\"kw\">struct </span>A(u32);\n<span class=\"attr\">#[derive(Component)]\n</span><span class=\"kw\">struct </span>B(u32);\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>world = World::new();\nworld.insert_resource(A(<span class=\"number\">1</span>));\n<span class=\"kw\">let </span>entity = world.spawn(B(<span class=\"number\">1</span>)).id();\n\nworld.resource_scope(|world, <span class=\"kw-2\">mut </span>a: Mut&lt;A&gt;| {\n    <span class=\"kw\">let </span>b = world.get_mut::&lt;B&gt;(entity).unwrap();\n    a.<span class=\"number\">0 </span>+= b.<span class=\"number\">0</span>;\n});\n<span class=\"macro\">assert_eq!</span>(world.get_resource::&lt;A&gt;().unwrap().<span class=\"number\">0</span>, <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.send_event\" class=\"fn\">send_event</a>&lt;E&gt;(&amp;mut self, event: E)<span class=\"where fmt-newline\">where\n    E: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\">Event</a>,</span></h4></section></summary><div class=\"docblock\"><p>Sends an <a href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\"><code>Event</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event_default\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.send_event_default\" class=\"fn\">send_event_default</a>&lt;E&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    E: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\">Event</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a>,</span></h4></section></summary><div class=\"docblock\"><p>Sends the default value of the <a href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\"><code>Event</code></a> of type <code>E</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_event_batch\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.send_event_batch\" class=\"fn\">send_event_batch</a>&lt;E&gt;(&amp;mut self, events: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/iter/traits/collect/trait.IntoIterator.html\" title=\"trait core::iter::traits::collect::IntoIterator\">IntoIterator</a>&lt;Item = E&gt;)<span class=\"where fmt-newline\">where\n    E: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\">Event</a>,</span></h4></section></summary><div class=\"docblock\"><p>Sends a batch of <a href=\"foliage/bevy_ecs/prelude/trait.Event.html\" title=\"trait foliage::bevy_ecs::prelude::Event\"><code>Event</code></a>s from an iterator.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.insert_resource_by_id\" class=\"fn\">insert_resource_by_id</a>(\n    &amp;mut self,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>,\n    value: <a class=\"struct\" href=\"foliage/bevy_ecs/ptr/struct.OwningPtr.html\" title=\"struct foliage::bevy_ecs::ptr::OwningPtr\">OwningPtr</a>&lt;'_&gt;\n)</h4></section></summary><div class=\"docblock\"><p>Inserts a new resource with the given <code>value</code>. Will replace the value if it already existed.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.insert_resource\" title=\"method foliage::bevy_ecs::prelude::World::insert_resource\"><code>World::insert_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"safety-1\"><a href=\"#safety-1\">Safety</a></h5>\n<p>The value referenced by <code>value</code> must be valid for the given <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> of this world.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub unsafe fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.insert_non_send_by_id\" class=\"fn\">insert_non_send_by_id</a>(\n    &amp;mut self,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>,\n    value: <a class=\"struct\" href=\"foliage/bevy_ecs/ptr/struct.OwningPtr.html\" title=\"struct foliage::bevy_ecs::ptr::OwningPtr\">OwningPtr</a>&lt;'_&gt;\n)</h4></section></summary><div class=\"docblock\"><p>Inserts a new <code>!Send</code> resource with the given <code>value</code>. Will replace the value if it already\nexisted.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.insert_non_send_resource\" title=\"method foliage::bevy_ecs::prelude::World::insert_non_send_resource\"><code>World::insert_non_send_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-12\"><a href=\"#panics-12\">Panics</a></h5>\n<p>If a value is already present, this function will panic if not called from the same\nthread that the original value was inserted from.</p>\n<h5 id=\"safety-2\"><a href=\"#safety-2\">Safety</a></h5>\n<p>The value referenced by <code>value</code> must be valid for the given <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> of this world.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.increment_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.increment_change_tick\" class=\"fn\">increment_change_tick</a>(&amp;self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.Tick.html\" title=\"struct foliage::bevy_ecs::component::Tick\">Tick</a></h4></section></summary><div class=\"docblock\"><p>Increments the world’s current change tick and returns the old value.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.read_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.read_change_tick\" class=\"fn\">read_change_tick</a>(&amp;self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.Tick.html\" title=\"struct foliage::bevy_ecs::component::Tick\">Tick</a></h4></section></summary><div class=\"docblock\"><p>Reads the current change tick of this world.</p>\n<p>If you have exclusive (<code>&amp;mut</code>) access to the world, consider using <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.change_tick\" title=\"method foliage::bevy_ecs::prelude::World::change_tick\"><code>change_tick()</code></a>,\nwhich is more efficient since it does not require atomic synchronization.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.change_tick\" class=\"fn\">change_tick</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.Tick.html\" title=\"struct foliage::bevy_ecs::component::Tick\">Tick</a></h4></section></summary><div class=\"docblock\"><p>Reads the current change tick of this world.</p>\n<p>This does the same thing as <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.read_change_tick\" title=\"method foliage::bevy_ecs::prelude::World::read_change_tick\"><code>read_change_tick()</code></a>, only this method\nis more efficient since it does not require atomic synchronization.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last_change_tick\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.last_change_tick\" class=\"fn\">last_change_tick</a>(&amp;self) -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.Tick.html\" title=\"struct foliage::bevy_ecs::component::Tick\">Tick</a></h4></section></summary><div class=\"docblock\"><p>When called from within an exclusive system (a <a href=\"foliage/bevy_ecs/prelude/trait.System.html\" title=\"trait foliage::bevy_ecs::prelude::System\"><code>System</code></a> that takes <code>&amp;mut World</code> as its first\nparameter), this method returns the <a href=\"foliage/bevy_ecs/component/struct.Tick.html\" title=\"struct foliage::bevy_ecs::component::Tick\"><code>Tick</code></a> indicating the last time the exclusive system was run.</p>\n<p>Otherwise, this returns the <code>Tick</code> indicating the last time that <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_trackers\" title=\"method foliage::bevy_ecs::prelude::World::clear_trackers\"><code>World::clear_trackers</code></a> was called.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_change_ticks\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.check_change_ticks\" class=\"fn\">check_change_ticks</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Iterates all component change ticks and clamps any older than <a href=\"foliage/bevy_ecs/change_detection/constant.MAX_CHANGE_AGE.html\" title=\"constant foliage::bevy_ecs::change_detection::MAX_CHANGE_AGE\"><code>MAX_CHANGE_AGE</code></a>.\nThis prevents overflow and thus prevents false positives.</p>\n<p><strong>Note:</strong> Does nothing if the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> counter has not been incremented at least <a href=\"foliage/bevy_ecs/world/constant.CHECK_TICK_THRESHOLD.html\" title=\"constant foliage::bevy_ecs::world::CHECK_TICK_THRESHOLD\"><code>CHECK_TICK_THRESHOLD</code></a>\ntimes since the previous pass.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_all\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.clear_all\" class=\"fn\">clear_all</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Runs both <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_entities\" title=\"method foliage::bevy_ecs::prelude::World::clear_entities\"><code>clear_entities</code></a> and <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.clear_resources\" title=\"method foliage::bevy_ecs::prelude::World::clear_resources\"><code>clear_resources</code></a>,\ninvalidating all <a href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\"><code>Entity</code></a> and resource fetches such as <a href=\"foliage/bevy_ecs/prelude/struct.Res.html\" title=\"struct foliage::bevy_ecs::prelude::Res\"><code>Res</code></a>, <a href=\"foliage/bevy_ecs/prelude/struct.ResMut.html\" title=\"struct foliage::bevy_ecs::prelude::ResMut\"><code>ResMut</code></a></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_entities\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.clear_entities\" class=\"fn\">clear_entities</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Despawns all entities in this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_resources\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.clear_resources\" class=\"fn\">clear_resources</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Clears all resources in this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a>.</p>\n<p><strong>Note:</strong> Any resource fetch to this <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> will fail unless they are re-initialized,\nincluding engine-internal resources that are only initialized on app/world construction.</p>\n<p>This can easily cause systems expecting certain resources to immediately start panicking.\nUse with caution.</p>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_resource_by_id\" class=\"fn\">get_resource_by_id</a>(&amp;self, component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/ptr/struct.Ptr.html\" title=\"struct foliage::bevy_ecs::ptr::Ptr\">Ptr</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the resource with the id <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> if it exists.\nThe returned pointer must not be used to modify the resource, and must not be\ndereferenced after the immutable borrow of the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> ends.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource\" title=\"method foliage::bevy_ecs::prelude::World::get_resource\"><code>World::get_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_resource_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_resource_mut_by_id\" class=\"fn\">get_resource_mut_by_id</a>(\n    &amp;mut self,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/change_detection/struct.MutUntyped.html\" title=\"struct foliage::bevy_ecs::change_detection::MutUntyped\">MutUntyped</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a pointer to the resource with the id <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> if it exists.\nThe returned pointer may be used to modify the resource, as long as the mutable borrow\nof the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> is still valid.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_mut\"><code>World::get_resource_mut</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_non_send_by_id\" class=\"fn\">get_non_send_by_id</a>(&amp;self, component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/ptr/struct.Ptr.html\" title=\"struct foliage::bevy_ecs::ptr::Ptr\">Ptr</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a <code>!Send</code> resource to the resource with the id <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> if it exists.\nThe returned pointer must not be used to modify the resource, and must not be\ndereferenced after the immutable borrow of the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> ends.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource\" title=\"method foliage::bevy_ecs::prelude::World::get_resource\"><code>World::get_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_non_send_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_non_send_mut_by_id\" class=\"fn\">get_non_send_mut_by_id</a>(\n    &amp;mut self,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/change_detection/struct.MutUntyped.html\" title=\"struct foliage::bevy_ecs::change_detection::MutUntyped\">MutUntyped</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Gets a <code>!Send</code> resource to the resource with the id <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a> if it exists.\nThe returned pointer may be used to modify the resource, as long as the mutable borrow\nof the <a href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\"><code>World</code></a> is still valid.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_resource_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_resource_mut\"><code>World::get_resource_mut</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_resource_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.remove_resource_by_id\" class=\"fn\">remove_resource_by_id</a>(&amp;mut self, component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type, if it exists. Otherwise returns <code>None</code>.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.remove_resource\" title=\"method foliage::bevy_ecs::prelude::World::remove_resource\"><code>World::remove_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_non_send_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.remove_non_send_by_id\" class=\"fn\">remove_non_send_by_id</a>(&amp;mut self, component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the resource of a given type, if it exists. Otherwise returns <code>None</code>.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.remove_resource\" title=\"method foliage::bevy_ecs::prelude::World::remove_resource\"><code>World::remove_resource</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-2\"><a href=\"#panics-2\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_by_id\" class=\"fn\">get_by_id</a>(\n    &amp;self,\n    entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/ptr/struct.Ptr.html\" title=\"struct foliage::bevy_ecs::ptr::Ptr\">Ptr</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves an immutable untyped reference to the given <code>entity</code>’s <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a>.\nReturns <code>None</code> if the <code>entity</code> does not have a <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_mut\"><code>World::get_mut</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n<h5 id=\"panics-3\"><a href=\"#panics-3\">Panics</a></h5>\n<p>This function will panic if it isn’t called from the same thread that the resource was inserted from.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut_by_id\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.get_mut_by_id\" class=\"fn\">get_mut_by_id</a>(\n    &amp;mut self,\n    entity: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Entity.html\" title=\"struct foliage::bevy_ecs::prelude::Entity\">Entity</a>,\n    component_id: <a class=\"struct\" href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\">ComponentId</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"foliage/bevy_ecs/change_detection/struct.MutUntyped.html\" title=\"struct foliage::bevy_ecs::change_detection::MutUntyped\">MutUntyped</a>&lt;'_&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Retrieves a mutable untyped reference to the given <code>entity</code>’s <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given <a href=\"foliage/bevy_ecs/component/struct.ComponentId.html\" title=\"struct foliage::bevy_ecs::component::ComponentId\"><code>ComponentId</code></a>.\nReturns <code>None</code> if the <code>entity</code> does not have a <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a> of the given type.</p>\n<p><strong>You should prefer to use the typed API <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.get_mut\" title=\"method foliage::bevy_ecs::prelude::World::get_mut\"><code>World::get_mut</code></a> where possible and only\nuse this in cases where the actual types are not known at compile time.</strong></p>\n</div></details></div></details>",0,"foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-World\" class=\"impl\"><a href=\"#impl-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.add_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.add_schedule\" class=\"fn\">add_schedule</a>(&amp;mut self, schedule: <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\">Schedule</a>)</h4></section></summary><div class=\"docblock\"><p>Adds the specified <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> to the world. The schedule can later be run\nby calling <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.run_schedule\" title=\"method foliage::bevy_ecs::prelude::World::run_schedule\"><code>.run_schedule(label)</code></a> or by directly\naccessing the <a href=\"foliage/bevy_ecs/prelude/struct.Schedules.html\" title=\"struct foliage::bevy_ecs::prelude::Schedules\"><code>Schedules</code></a> resource.</p>\n<p>The <code>Schedules</code> resource will be initialized if it does not already exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_schedule_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.try_schedule_scope\" class=\"fn\">try_schedule_scope</a>&lt;R&gt;(\n    &amp;mut self,\n    label: impl <a class=\"trait\" href=\"foliage/bevy_ecs/schedule/trait.ScheduleLabel.html\" title=\"trait foliage::bevy_ecs::schedule::ScheduleLabel\">ScheduleLabel</a>,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a>, &amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\">Schedule</a>) -&gt; R\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;R, <a class=\"struct\" href=\"foliage/bevy_ecs/world/error/struct.TryRunScheduleError.html\" title=\"struct foliage::bevy_ecs::world::error::TryRunScheduleError\">TryRunScheduleError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Temporarily removes the schedule associated with <code>label</code> from the world,\nruns user code, and finally re-adds the schedule.\nThis returns a <a href=\"foliage/bevy_ecs/world/error/struct.TryRunScheduleError.html\" title=\"struct foliage::bevy_ecs::world::error::TryRunScheduleError\"><code>TryRunScheduleError</code></a> if there is no schedule\nassociated with <code>label</code>.</p>\n<p>The <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> is fetched from the <a href=\"foliage/bevy_ecs/prelude/struct.Schedules.html\" title=\"struct foliage::bevy_ecs::prelude::Schedules\"><code>Schedules</code></a> resource of the world by its label,\nand system state is cached.</p>\n<p>For simple cases where you just need to call the schedule once,\nconsider using <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.try_run_schedule\" title=\"method foliage::bevy_ecs::prelude::World::try_run_schedule\"><code>World::try_run_schedule</code></a> instead.\nFor other use cases, see the example on <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.schedule_scope\" title=\"method foliage::bevy_ecs::prelude::World::schedule_scope\"><code>World::schedule_scope</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.schedule_scope\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.schedule_scope\" class=\"fn\">schedule_scope</a>&lt;R&gt;(\n    &amp;mut self,\n    label: impl <a class=\"trait\" href=\"foliage/bevy_ecs/schedule/trait.ScheduleLabel.html\" title=\"trait foliage::bevy_ecs::schedule::ScheduleLabel\">ScheduleLabel</a>,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a>, &amp;mut <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\">Schedule</a>) -&gt; R\n) -&gt; R</h4></section></summary><div class=\"docblock\"><p>Temporarily removes the schedule associated with <code>label</code> from the world,\nruns user code, and finally re-adds the schedule.</p>\n<p>The <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> is fetched from the <a href=\"foliage/bevy_ecs/prelude/struct.Schedules.html\" title=\"struct foliage::bevy_ecs::prelude::Schedules\"><code>Schedules</code></a> resource of the world by its label,\nand system state is cached.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// Run the schedule five times.\n</span>world.schedule_scope(MySchedule, |world, schedule| {\n    <span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">5 </span>{\n        schedule.run(world);\n    }\n});</code></pre></div>\n<p>For simple cases where you just need to call the schedule once,\nconsider using <a href=\"foliage/bevy_ecs/prelude/struct.World.html#method.run_schedule\" title=\"method foliage::bevy_ecs::prelude::World::run_schedule\"><code>World::run_schedule</code></a> instead.</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>If the requested schedule does not exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_run_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.try_run_schedule\" class=\"fn\">try_run_schedule</a>(\n    &amp;mut self,\n    label: impl <a class=\"trait\" href=\"foliage/bevy_ecs/schedule/trait.ScheduleLabel.html\" title=\"trait foliage::bevy_ecs::schedule::ScheduleLabel\">ScheduleLabel</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"foliage/bevy_ecs/world/error/struct.TryRunScheduleError.html\" title=\"struct foliage::bevy_ecs::world::error::TryRunScheduleError\">TryRunScheduleError</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to run the <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> associated with the <code>label</code> a single time,\nand returns a <a href=\"foliage/bevy_ecs/world/error/struct.TryRunScheduleError.html\" title=\"struct foliage::bevy_ecs::world::error::TryRunScheduleError\"><code>TryRunScheduleError</code></a> if the schedule does not exist.</p>\n<p>The <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> is fetched from the <a href=\"foliage/bevy_ecs/prelude/struct.Schedules.html\" title=\"struct foliage::bevy_ecs::prelude::Schedules\"><code>Schedules</code></a> resource of the world by its label,\nand system state is cached.</p>\n<p>For simple testing use cases, call <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html#method.run\" title=\"method foliage::bevy_ecs::prelude::Schedule::run\"><code>Schedule::run(&amp;mut world)</code></a> instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.run_schedule\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.run_schedule\" class=\"fn\">run_schedule</a>(&amp;mut self, label: impl <a class=\"trait\" href=\"foliage/bevy_ecs/schedule/trait.ScheduleLabel.html\" title=\"trait foliage::bevy_ecs::schedule::ScheduleLabel\">ScheduleLabel</a>)</h4></section></summary><div class=\"docblock\"><p>Runs the <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> associated with the <code>label</code> a single time.</p>\n<p>The <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html\" title=\"struct foliage::bevy_ecs::prelude::Schedule\"><code>Schedule</code></a> is fetched from the <a href=\"foliage/bevy_ecs/prelude/struct.Schedules.html\" title=\"struct foliage::bevy_ecs::prelude::Schedules\"><code>Schedules</code></a> resource of the world by its label,\nand system state is cached.</p>\n<p>For simple testing use cases, call <a href=\"foliage/bevy_ecs/prelude/struct.Schedule.html#method.run\" title=\"method foliage::bevy_ecs::prelude::Schedule::run\"><code>Schedule::run(&amp;mut world)</code></a> instead.</p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>If the requested schedule does not exist.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allow_ambiguous_component\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.allow_ambiguous_component\" class=\"fn\">allow_ambiguous_component</a>&lt;T&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\">Component</a>,</span></h4></section></summary><div class=\"docblock\"><p>Ignore system order ambiguities caused by conflicts on <a href=\"foliage/bevy_ecs/prelude/trait.Component.html\" title=\"trait foliage::bevy_ecs::prelude::Component\"><code>Component</code></a>s of type <code>T</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allow_ambiguous_resource\" class=\"method\"><h4 class=\"code-header\">pub fn <a href=\"foliage/bevy_ecs/prelude/struct.World.html#tymethod.allow_ambiguous_resource\" class=\"fn\">allow_ambiguous_resource</a>&lt;T&gt;(&amp;mut self)<span class=\"where fmt-newline\">where\n    T: <a class=\"trait\" href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\">Resource</a>,</span></h4></section></summary><div class=\"docblock\"><p>Ignore system order ambiguities caused by conflicts on <a href=\"foliage/bevy_ecs/prelude/trait.Resource.html\" title=\"trait foliage::bevy_ecs::prelude::Resource\"><code>Resource</code></a>s of type <code>T</code>.</p>\n</div></details></div></details>",0,"foliage::job::Container"],["<section id=\"impl-Sync-for-World\" class=\"impl\"><a href=\"#impl-Sync-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section>","Sync","foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-World\" class=\"impl\"><a href=\"#impl-Default-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a> for <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href=\"https://doc.rust-lang.org/1.75.0/core/default/trait.Default.html#tymethod.default\">Read more</a></div></details></div></details>","Default","foliage::job::Container"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-World\" class=\"impl\"><a href=\"#impl-Debug-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.75.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.75.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.75.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.75.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","foliage::job::Container"],["<section id=\"impl-Send-for-World\" class=\"impl\"><a href=\"#impl-Send-for-World\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.75.0/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> for <a class=\"struct\" href=\"foliage/bevy_ecs/prelude/struct.World.html\" title=\"struct foliage::bevy_ecs::prelude::World\">World</a></h3></section>","Send","foliage::job::Container"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()